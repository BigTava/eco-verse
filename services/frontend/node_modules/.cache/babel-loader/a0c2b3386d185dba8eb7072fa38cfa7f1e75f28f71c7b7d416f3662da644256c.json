{"ast":null,"code":"import B, { Fragment as G, createContext as V, createRef as N, useContext as X, useEffect as $, useMemo as P, useReducer as q, useRef as H } from \"react\";\nimport { match as K } from '../../utils/match.js';\nimport { forwardRefWithAs as v, render as x, Features as j } from '../../utils/render.js';\nimport { disposables as L } from '../../utils/disposables.js';\nimport { useDisposables as Q } from '../../hooks/use-disposables.js';\nimport { useIsoMorphicEffect as h } from '../../hooks/use-iso-morphic-effect.js';\nimport { useSyncRefs as D } from '../../hooks/use-sync-refs.js';\nimport { useId as k } from '../../hooks/use-id.js';\nimport { Keys as d } from '../keyboard.js';\nimport { Focus as y, calculateActiveIndex as z } from '../../utils/calculate-active-index.js';\nimport { isDisabledReactIssue7711 as Y } from '../../utils/bugs.js';\nimport { isFocusableElement as Z, FocusableMode as ee, sortByDomNode as te, Focus as W, focusFrom as ne, restoreFocusIfNecessary as J } from '../../utils/focus-management.js';\nimport { useOutsideClick as re } from '../../hooks/use-outside-click.js';\nimport { useTreeWalker as oe } from '../../hooks/use-tree-walker.js';\nimport { useOpenClosed as ae, State as C, OpenClosedProvider as se } from '../../internal/open-closed.js';\nimport { useResolveButtonType as ie } from '../../hooks/use-resolve-button-type.js';\nimport { useOwnerDocument as ue } from '../../hooks/use-owner.js';\nimport { useEvent as T } from '../../hooks/use-event.js';\nimport { useTrackedPointer as le } from '../../hooks/use-tracked-pointer.js';\nvar pe = (r => (r[r.Open = 0] = \"Open\", r[r.Closed = 1] = \"Closed\", r))(pe || {}),\n  ce = (r => (r[r.Pointer = 0] = \"Pointer\", r[r.Other = 1] = \"Other\", r))(ce || {}),\n  me = (a => (a[a.OpenMenu = 0] = \"OpenMenu\", a[a.CloseMenu = 1] = \"CloseMenu\", a[a.GoToItem = 2] = \"GoToItem\", a[a.Search = 3] = \"Search\", a[a.ClearSearch = 4] = \"ClearSearch\", a[a.RegisterItem = 5] = \"RegisterItem\", a[a.UnregisterItem = 6] = \"UnregisterItem\", a))(me || {});\nfunction w(e) {\n  let u = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : r => r;\n  let r = e.activeItemIndex !== null ? e.items[e.activeItemIndex] : null,\n    i = te(u(e.items.slice()), t => t.dataRef.current.domRef.current),\n    s = r ? i.indexOf(r) : null;\n  return s === -1 && (s = null), {\n    items: i,\n    activeItemIndex: s\n  };\n}\nlet de = {\n    [1](e) {\n      return e.menuState === 1 ? e : {\n        ...e,\n        activeItemIndex: null,\n        menuState: 1\n      };\n    },\n    [0](e) {\n      return e.menuState === 0 ? e : {\n        ...e,\n        menuState: 0\n      };\n    },\n    [2]: (e, u) => {\n      var s;\n      let r = w(e),\n        i = z(u, {\n          resolveItems: () => r.items,\n          resolveActiveIndex: () => r.activeItemIndex,\n          resolveId: t => t.id,\n          resolveDisabled: t => t.dataRef.current.disabled\n        });\n      return {\n        ...e,\n        ...r,\n        searchQuery: \"\",\n        activeItemIndex: i,\n        activationTrigger: (s = u.trigger) != null ? s : 1\n      };\n    },\n    [3]: (e, u) => {\n      let i = e.searchQuery !== \"\" ? 0 : 1,\n        s = e.searchQuery + u.value.toLowerCase(),\n        o = (e.activeItemIndex !== null ? e.items.slice(e.activeItemIndex + i).concat(e.items.slice(0, e.activeItemIndex + i)) : e.items).find(l => {\n          var m;\n          return ((m = l.dataRef.current.textValue) == null ? void 0 : m.startsWith(s)) && !l.dataRef.current.disabled;\n        }),\n        a = o ? e.items.indexOf(o) : -1;\n      return a === -1 || a === e.activeItemIndex ? {\n        ...e,\n        searchQuery: s\n      } : {\n        ...e,\n        searchQuery: s,\n        activeItemIndex: a,\n        activationTrigger: 1\n      };\n    },\n    [4](e) {\n      return e.searchQuery === \"\" ? e : {\n        ...e,\n        searchQuery: \"\",\n        searchActiveItemIndex: null\n      };\n    },\n    [5]: (e, u) => {\n      let r = w(e, i => [...i, {\n        id: u.id,\n        dataRef: u.dataRef\n      }]);\n      return {\n        ...e,\n        ...r\n      };\n    },\n    [6]: (e, u) => {\n      let r = w(e, i => {\n        let s = i.findIndex(t => t.id === u.id);\n        return s !== -1 && i.splice(s, 1), i;\n      });\n      return {\n        ...e,\n        ...r,\n        activationTrigger: 1\n      };\n    }\n  },\n  U = V(null);\nU.displayName = \"MenuContext\";\nfunction F(e) {\n  let u = X(U);\n  if (u === null) {\n    let r = new Error(`<${e} /> is missing a parent <Menu /> component.`);\n    throw Error.captureStackTrace && Error.captureStackTrace(r, F), r;\n  }\n  return u;\n}\nfunction fe(e, u) {\n  return K(u.type, de, e, u);\n}\nlet Te = G;\nfunction ye(e, u) {\n  let r = q(fe, {\n      menuState: 1,\n      buttonRef: N(),\n      itemsRef: N(),\n      items: [],\n      searchQuery: \"\",\n      activeItemIndex: null,\n      activationTrigger: 1\n    }),\n    [{\n      menuState: i,\n      itemsRef: s,\n      buttonRef: t\n    }, o] = r,\n    a = D(u);\n  re([t, s], (g, A) => {\n    var I;\n    o({\n      type: 1\n    }), Z(A, ee.Loose) || (g.preventDefault(), (I = t.current) == null || I.focus());\n  }, i === 0);\n  let l = T(() => {\n      o({\n        type: 1\n      });\n    }),\n    m = P(() => ({\n      open: i === 0,\n      close: l\n    }), [i, l]),\n    M = e,\n    f = {\n      ref: a\n    };\n  return B.createElement(U.Provider, {\n    value: r\n  }, B.createElement(se, {\n    value: K(i, {\n      [0]: C.Open,\n      [1]: C.Closed\n    })\n  }, x({\n    ourProps: f,\n    theirProps: M,\n    slot: m,\n    defaultTag: Te,\n    name: \"Menu\"\n  })));\n}\nlet Ie = \"button\";\nfunction Me(e, u) {\n  var I;\n  let r = k(),\n    {\n      id: i = `headlessui-menu-button-${r}`,\n      ...s\n    } = e,\n    [t, o] = F(\"Menu.Button\"),\n    a = D(t.buttonRef, u),\n    l = Q(),\n    m = T(p => {\n      switch (p.key) {\n        case d.Space:\n        case d.Enter:\n        case d.ArrowDown:\n          p.preventDefault(), p.stopPropagation(), o({\n            type: 0\n          }), l.nextFrame(() => o({\n            type: 2,\n            focus: y.First\n          }));\n          break;\n        case d.ArrowUp:\n          p.preventDefault(), p.stopPropagation(), o({\n            type: 0\n          }), l.nextFrame(() => o({\n            type: 2,\n            focus: y.Last\n          }));\n          break;\n      }\n    }),\n    M = T(p => {\n      switch (p.key) {\n        case d.Space:\n          p.preventDefault();\n          break;\n      }\n    }),\n    f = T(p => {\n      if (Y(p.currentTarget)) return p.preventDefault();\n      e.disabled || (t.menuState === 0 ? (o({\n        type: 1\n      }), l.nextFrame(() => {\n        var R;\n        return (R = t.buttonRef.current) == null ? void 0 : R.focus({\n          preventScroll: !0\n        });\n      })) : (p.preventDefault(), o({\n        type: 0\n      })));\n    }),\n    g = P(() => ({\n      open: t.menuState === 0\n    }), [t]),\n    A = {\n      ref: a,\n      id: i,\n      type: ie(e, t.buttonRef),\n      \"aria-haspopup\": \"menu\",\n      \"aria-controls\": (I = t.itemsRef.current) == null ? void 0 : I.id,\n      \"aria-expanded\": e.disabled ? void 0 : t.menuState === 0,\n      onKeyDown: m,\n      onKeyUp: M,\n      onClick: f\n    };\n  return x({\n    ourProps: A,\n    theirProps: s,\n    slot: g,\n    defaultTag: Ie,\n    name: \"Menu.Button\"\n  });\n}\nlet ge = \"div\",\n  Re = j.RenderStrategy | j.Static;\nfunction Ae(e, u) {\n  var R, E;\n  let r = k(),\n    {\n      id: i = `headlessui-menu-items-${r}`,\n      ...s\n    } = e,\n    [t, o] = F(\"Menu.Items\"),\n    a = D(t.itemsRef, u),\n    l = ue(t.itemsRef),\n    m = Q(),\n    M = ae(),\n    f = (() => M !== null ? (M & C.Open) === C.Open : t.menuState === 0)();\n  $(() => {\n    let n = t.itemsRef.current;\n    n && t.menuState === 0 && n !== (l == null ? void 0 : l.activeElement) && n.focus({\n      preventScroll: !0\n    });\n  }, [t.menuState, t.itemsRef, l]), oe({\n    container: t.itemsRef.current,\n    enabled: t.menuState === 0,\n    accept(n) {\n      return n.getAttribute(\"role\") === \"menuitem\" ? NodeFilter.FILTER_REJECT : n.hasAttribute(\"role\") ? NodeFilter.FILTER_SKIP : NodeFilter.FILTER_ACCEPT;\n    },\n    walk(n) {\n      n.setAttribute(\"role\", \"none\");\n    }\n  });\n  let g = T(n => {\n      var S, O;\n      switch (m.dispose(), n.key) {\n        case d.Space:\n          if (t.searchQuery !== \"\") return n.preventDefault(), n.stopPropagation(), o({\n            type: 3,\n            value: n.key\n          });\n        case d.Enter:\n          if (n.preventDefault(), n.stopPropagation(), o({\n            type: 1\n          }), t.activeItemIndex !== null) {\n            let {\n              dataRef: c\n            } = t.items[t.activeItemIndex];\n            (O = (S = c.current) == null ? void 0 : S.domRef.current) == null || O.click();\n          }\n          J(t.buttonRef.current);\n          break;\n        case d.ArrowDown:\n          return n.preventDefault(), n.stopPropagation(), o({\n            type: 2,\n            focus: y.Next\n          });\n        case d.ArrowUp:\n          return n.preventDefault(), n.stopPropagation(), o({\n            type: 2,\n            focus: y.Previous\n          });\n        case d.Home:\n        case d.PageUp:\n          return n.preventDefault(), n.stopPropagation(), o({\n            type: 2,\n            focus: y.First\n          });\n        case d.End:\n        case d.PageDown:\n          return n.preventDefault(), n.stopPropagation(), o({\n            type: 2,\n            focus: y.Last\n          });\n        case d.Escape:\n          n.preventDefault(), n.stopPropagation(), o({\n            type: 1\n          }), L().nextFrame(() => {\n            var c;\n            return (c = t.buttonRef.current) == null ? void 0 : c.focus({\n              preventScroll: !0\n            });\n          });\n          break;\n        case d.Tab:\n          n.preventDefault(), n.stopPropagation(), o({\n            type: 1\n          }), L().nextFrame(() => {\n            ne(t.buttonRef.current, n.shiftKey ? W.Previous : W.Next);\n          });\n          break;\n        default:\n          n.key.length === 1 && (o({\n            type: 3,\n            value: n.key\n          }), m.setTimeout(() => o({\n            type: 4\n          }), 350));\n          break;\n      }\n    }),\n    A = T(n => {\n      switch (n.key) {\n        case d.Space:\n          n.preventDefault();\n          break;\n      }\n    }),\n    I = P(() => ({\n      open: t.menuState === 0\n    }), [t]),\n    p = {\n      \"aria-activedescendant\": t.activeItemIndex === null || (R = t.items[t.activeItemIndex]) == null ? void 0 : R.id,\n      \"aria-labelledby\": (E = t.buttonRef.current) == null ? void 0 : E.id,\n      id: i,\n      onKeyDown: g,\n      onKeyUp: A,\n      role: \"menu\",\n      tabIndex: 0,\n      ref: a\n    };\n  return x({\n    ourProps: p,\n    theirProps: s,\n    slot: I,\n    defaultTag: ge,\n    features: Re,\n    visible: f,\n    name: \"Menu.Items\"\n  });\n}\nlet be = G;\nfunction Ee(e, u) {\n  let r = k(),\n    {\n      id: i = `headlessui-menu-item-${r}`,\n      disabled: s = !1,\n      ...t\n    } = e,\n    [o, a] = F(\"Menu.Item\"),\n    l = o.activeItemIndex !== null ? o.items[o.activeItemIndex].id === i : !1,\n    m = H(null),\n    M = D(u, m);\n  h(() => {\n    if (o.menuState !== 0 || !l || o.activationTrigger === 0) return;\n    let c = L();\n    return c.requestAnimationFrame(() => {\n      var b, _;\n      (_ = (b = m.current) == null ? void 0 : b.scrollIntoView) == null || _.call(b, {\n        block: \"nearest\"\n      });\n    }), c.dispose;\n  }, [m, l, o.menuState, o.activationTrigger, o.activeItemIndex]);\n  let f = H({\n    disabled: s,\n    domRef: m\n  });\n  h(() => {\n    f.current.disabled = s;\n  }, [f, s]), h(() => {\n    var c, b;\n    f.current.textValue = (b = (c = m.current) == null ? void 0 : c.textContent) == null ? void 0 : b.toLowerCase();\n  }, [f, m]), h(() => (a({\n    type: 5,\n    id: i,\n    dataRef: f\n  }), () => a({\n    type: 6,\n    id: i\n  })), [f, i]);\n  let g = T(() => {\n      a({\n        type: 1\n      });\n    }),\n    A = T(c => {\n      if (s) return c.preventDefault();\n      a({\n        type: 1\n      }), J(o.buttonRef.current);\n    }),\n    I = T(() => {\n      if (s) return a({\n        type: 2,\n        focus: y.Nothing\n      });\n      a({\n        type: 2,\n        focus: y.Specific,\n        id: i\n      });\n    }),\n    p = le(),\n    R = T(c => p.update(c)),\n    E = T(c => {\n      p.wasMoved(c) && (s || l || a({\n        type: 2,\n        focus: y.Specific,\n        id: i,\n        trigger: 0\n      }));\n    }),\n    n = T(c => {\n      p.wasMoved(c) && (s || l && a({\n        type: 2,\n        focus: y.Nothing\n      }));\n    }),\n    S = P(() => ({\n      active: l,\n      disabled: s,\n      close: g\n    }), [l, s, g]);\n  return x({\n    ourProps: {\n      id: i,\n      ref: M,\n      role: \"menuitem\",\n      tabIndex: s === !0 ? void 0 : -1,\n      \"aria-disabled\": s === !0 ? !0 : void 0,\n      disabled: void 0,\n      onClick: A,\n      onFocus: I,\n      onPointerEnter: R,\n      onMouseEnter: R,\n      onPointerMove: E,\n      onMouseMove: E,\n      onPointerLeave: n,\n      onMouseLeave: n\n    },\n    theirProps: t,\n    slot: S,\n    defaultTag: be,\n    name: \"Menu.Item\"\n  });\n}\nlet Se = v(ye),\n  Pe = v(Me),\n  ve = v(Ae),\n  xe = v(Ee),\n  ot = Object.assign(Se, {\n    Button: Pe,\n    Items: ve,\n    Item: xe\n  });\nexport { ot as Menu };","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}