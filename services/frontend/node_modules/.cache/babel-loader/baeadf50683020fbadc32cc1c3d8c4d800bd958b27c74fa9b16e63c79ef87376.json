{"ast":null,"code":"var Mt = Object.create;\nvar ne = Object.defineProperty,\n  xt = Object.defineProperties,\n  wt = Object.getOwnPropertyDescriptor,\n  Nt = Object.getOwnPropertyDescriptors,\n  $t = Object.getOwnPropertyNames,\n  De = Object.getOwnPropertySymbols,\n  At = Object.getPrototypeOf,\n  Ue = Object.prototype.hasOwnProperty,\n  Ct = Object.prototype.propertyIsEnumerable;\nvar We = (n, e, t) => e in n ? ne(n, e, {\n    enumerable: !0,\n    configurable: !0,\n    writable: !0,\n    value: t\n  }) : n[e] = t,\n  F = (n, e) => {\n    for (var t in e || (e = {})) Ue.call(e, t) && We(n, t, e[t]);\n    if (De) for (var t of De(e)) Ct.call(e, t) && We(n, t, e[t]);\n    return n;\n  },\n  re = (n, e) => xt(n, Nt(e));\nvar St = (n, e) => () => (e || n((e = {\n    exports: {}\n  }).exports, e), e.exports),\n  Lt = (n, e) => {\n    for (var t in e) ne(n, t, {\n      get: e[t],\n      enumerable: !0\n    });\n  },\n  Ot = (n, e, t, r) => {\n    if (e && typeof e == \"object\" || typeof e == \"function\") for (let o of $t(e)) !Ue.call(n, o) && o !== t && ne(n, o, {\n      get: () => e[o],\n      enumerable: !(r = wt(e, o)) || r.enumerable\n    });\n    return n;\n  };\nvar _t = (n, e, t) => (t = n != null ? Mt(At(n)) : {}, Ot(e || !n || !n.__esModule ? ne(t, \"default\", {\n  value: n,\n  enumerable: !0\n}) : t, n));\nvar E = (n, e, t) => new Promise((r, o) => {\n  var s = l => {\n      try {\n        i(t.next(l));\n      } catch (u) {\n        o(u);\n      }\n    },\n    a = l => {\n      try {\n        i(t.throw(l));\n      } catch (u) {\n        o(u);\n      }\n    },\n    i = l => l.done ? r(l.value) : Promise.resolve(l.value).then(s, a);\n  i((t = t.apply(n, e)).next());\n});\nvar mt = St((Pr, $e) => {\n  \"use strict\";\n\n  var Cn = Object.prototype.hasOwnProperty,\n    P = \"~\";\n  function Q() {}\n  Object.create && (Q.prototype = Object.create(null), new Q().__proto__ || (P = !1));\n  function Sn(n, e, t) {\n    this.fn = n, this.context = e, this.once = t || !1;\n  }\n  function pt(n, e, t, r, o) {\n    if (typeof t != \"function\") throw new TypeError(\"The listener must be a function\");\n    var s = new Sn(t, r || n, o),\n      a = P ? P + e : e;\n    return n._events[a] ? n._events[a].fn ? n._events[a] = [n._events[a], s] : n._events[a].push(s) : (n._events[a] = s, n._eventsCount++), n;\n  }\n  function de(n, e) {\n    --n._eventsCount === 0 ? n._events = new Q() : delete n._events[e];\n  }\n  function T() {\n    this._events = new Q(), this._eventsCount = 0;\n  }\n  T.prototype.eventNames = function () {\n    var e = [],\n      t,\n      r;\n    if (this._eventsCount === 0) return e;\n    for (r in t = this._events) Cn.call(t, r) && e.push(P ? r.slice(1) : r);\n    return Object.getOwnPropertySymbols ? e.concat(Object.getOwnPropertySymbols(t)) : e;\n  };\n  T.prototype.listeners = function (e) {\n    var t = P ? P + e : e,\n      r = this._events[t];\n    if (!r) return [];\n    if (r.fn) return [r.fn];\n    for (var o = 0, s = r.length, a = new Array(s); o < s; o++) a[o] = r[o].fn;\n    return a;\n  };\n  T.prototype.listenerCount = function (e) {\n    var t = P ? P + e : e,\n      r = this._events[t];\n    return r ? r.fn ? 1 : r.length : 0;\n  };\n  T.prototype.emit = function (e, t, r, o, s, a) {\n    var i = P ? P + e : e;\n    if (!this._events[i]) return !1;\n    var l = this._events[i],\n      u = arguments.length,\n      c,\n      d;\n    if (l.fn) {\n      switch (l.once && this.removeListener(e, l.fn, void 0, !0), u) {\n        case 1:\n          return l.fn.call(l.context), !0;\n        case 2:\n          return l.fn.call(l.context, t), !0;\n        case 3:\n          return l.fn.call(l.context, t, r), !0;\n        case 4:\n          return l.fn.call(l.context, t, r, o), !0;\n        case 5:\n          return l.fn.call(l.context, t, r, o, s), !0;\n        case 6:\n          return l.fn.call(l.context, t, r, o, s, a), !0;\n      }\n      for (d = 1, c = new Array(u - 1); d < u; d++) c[d - 1] = arguments[d];\n      l.fn.apply(l.context, c);\n    } else {\n      var x = l.length,\n        k;\n      for (d = 0; d < x; d++) switch (l[d].once && this.removeListener(e, l[d].fn, void 0, !0), u) {\n        case 1:\n          l[d].fn.call(l[d].context);\n          break;\n        case 2:\n          l[d].fn.call(l[d].context, t);\n          break;\n        case 3:\n          l[d].fn.call(l[d].context, t, r);\n          break;\n        case 4:\n          l[d].fn.call(l[d].context, t, r, o);\n          break;\n        default:\n          if (!c) for (k = 1, c = new Array(u - 1); k < u; k++) c[k - 1] = arguments[k];\n          l[d].fn.apply(l[d].context, c);\n      }\n    }\n    return !0;\n  };\n  T.prototype.on = function (e, t, r) {\n    return pt(this, e, t, r, !1);\n  };\n  T.prototype.once = function (e, t, r) {\n    return pt(this, e, t, r, !0);\n  };\n  T.prototype.removeListener = function (e, t, r, o) {\n    var s = P ? P + e : e;\n    if (!this._events[s]) return this;\n    if (!t) return de(this, s), this;\n    var a = this._events[s];\n    if (a.fn) a.fn === t && (!o || a.once) && (!r || a.context === r) && de(this, s);else {\n      for (var i = 0, l = [], u = a.length; i < u; i++) (a[i].fn !== t || o && !a[i].once || r && a[i].context !== r) && l.push(a[i]);\n      l.length ? this._events[s] = l.length === 1 ? l[0] : l : de(this, s);\n    }\n    return this;\n  };\n  T.prototype.removeAllListeners = function (e) {\n    var t;\n    return e ? (t = P ? P + e : e, this._events[t] && de(this, t)) : (this._events = new Q(), this._eventsCount = 0), this;\n  };\n  T.prototype.off = T.prototype.removeListener;\n  T.prototype.addListener = T.prototype.on;\n  T.prefixed = P;\n  T.EventEmitter = T;\n  typeof $e < \"u\" && ($e.exports = T);\n});\nfunction kt(n) {\n  let e = {\n    exports: {}\n  };\n  return n(e, e.exports), e.exports;\n}\nvar qt = Number.MAX_SAFE_INTEGER || 9007199254740991;\nvar we = {\n    SEMVER_SPEC_VERSION: \"2.0.0\",\n    MAX_LENGTH: 256,\n    MAX_SAFE_INTEGER: qt,\n    MAX_SAFE_COMPONENT_LENGTH: 16\n  },\n  Dt = typeof process == \"object\" && process.env && process.env.NODE_DEBUG && /\\bsemver\\b/i.test(process.env.NODE_DEBUG) ? function () {\n    for (var _len = arguments.length, n = new Array(_len), _key = 0; _key < _len; _key++) {\n      n[_key] = arguments[_key];\n    }\n    return console.error(\"SEMVER\", ...n);\n  } : () => {},\n  h = Dt,\n  Y = kt(function (n, e) {\n    let {\n        MAX_SAFE_COMPONENT_LENGTH: t\n      } = we,\n      r = (e = n.exports = {}).re = [],\n      o = e.src = [],\n      s = e.t = {},\n      a = 0,\n      i = (l, u, c) => {\n        let d = a++;\n        h(d, u), s[l] = d, o[d] = u, r[d] = new RegExp(u, c ? \"g\" : void 0);\n      };\n    i(\"NUMERICIDENTIFIER\", \"0|[1-9]\\\\d*\"), i(\"NUMERICIDENTIFIERLOOSE\", \"[0-9]+\"), i(\"NONNUMERICIDENTIFIER\", \"\\\\d*[a-zA-Z-][a-zA-Z0-9-]*\"), i(\"MAINVERSION\", `(${o[s.NUMERICIDENTIFIER]})\\\\.(${o[s.NUMERICIDENTIFIER]})\\\\.(${o[s.NUMERICIDENTIFIER]})`), i(\"MAINVERSIONLOOSE\", `(${o[s.NUMERICIDENTIFIERLOOSE]})\\\\.(${o[s.NUMERICIDENTIFIERLOOSE]})\\\\.(${o[s.NUMERICIDENTIFIERLOOSE]})`), i(\"PRERELEASEIDENTIFIER\", `(?:${o[s.NUMERICIDENTIFIER]}|${o[s.NONNUMERICIDENTIFIER]})`), i(\"PRERELEASEIDENTIFIERLOOSE\", `(?:${o[s.NUMERICIDENTIFIERLOOSE]}|${o[s.NONNUMERICIDENTIFIER]})`), i(\"PRERELEASE\", `(?:-(${o[s.PRERELEASEIDENTIFIER]}(?:\\\\.${o[s.PRERELEASEIDENTIFIER]})*))`), i(\"PRERELEASELOOSE\", `(?:-?(${o[s.PRERELEASEIDENTIFIERLOOSE]}(?:\\\\.${o[s.PRERELEASEIDENTIFIERLOOSE]})*))`), i(\"BUILDIDENTIFIER\", \"[0-9A-Za-z-]+\"), i(\"BUILD\", `(?:\\\\+(${o[s.BUILDIDENTIFIER]}(?:\\\\.${o[s.BUILDIDENTIFIER]})*))`), i(\"FULLPLAIN\", `v?${o[s.MAINVERSION]}${o[s.PRERELEASE]}?${o[s.BUILD]}?`), i(\"FULL\", `^${o[s.FULLPLAIN]}$`), i(\"LOOSEPLAIN\", `[v=\\\\s]*${o[s.MAINVERSIONLOOSE]}${o[s.PRERELEASELOOSE]}?${o[s.BUILD]}?`), i(\"LOOSE\", `^${o[s.LOOSEPLAIN]}$`), i(\"GTLT\", \"((?:<|>)?=?)\"), i(\"XRANGEIDENTIFIERLOOSE\", `${o[s.NUMERICIDENTIFIERLOOSE]}|x|X|\\\\*`), i(\"XRANGEIDENTIFIER\", `${o[s.NUMERICIDENTIFIER]}|x|X|\\\\*`), i(\"XRANGEPLAIN\", `[v=\\\\s]*(${o[s.XRANGEIDENTIFIER]})(?:\\\\.(${o[s.XRANGEIDENTIFIER]})(?:\\\\.(${o[s.XRANGEIDENTIFIER]})(?:${o[s.PRERELEASE]})?${o[s.BUILD]}?)?)?`), i(\"XRANGEPLAINLOOSE\", `[v=\\\\s]*(${o[s.XRANGEIDENTIFIERLOOSE]})(?:\\\\.(${o[s.XRANGEIDENTIFIERLOOSE]})(?:\\\\.(${o[s.XRANGEIDENTIFIERLOOSE]})(?:${o[s.PRERELEASELOOSE]})?${o[s.BUILD]}?)?)?`), i(\"XRANGE\", `^${o[s.GTLT]}\\\\s*${o[s.XRANGEPLAIN]}$`), i(\"XRANGELOOSE\", `^${o[s.GTLT]}\\\\s*${o[s.XRANGEPLAINLOOSE]}$`), i(\"COERCE\", `(^|[^\\\\d])(\\\\d{1,${t}})(?:\\\\.(\\\\d{1,${t}}))?(?:\\\\.(\\\\d{1,${t}}))?(?:$|[^\\\\d])`), i(\"COERCERTL\", o[s.COERCE], !0), i(\"LONETILDE\", \"(?:~>?)\"), i(\"TILDETRIM\", `(\\\\s*)${o[s.LONETILDE]}\\\\s+`, !0), e.tildeTrimReplace = \"$1~\", i(\"TILDE\", `^${o[s.LONETILDE]}${o[s.XRANGEPLAIN]}$`), i(\"TILDELOOSE\", `^${o[s.LONETILDE]}${o[s.XRANGEPLAINLOOSE]}$`), i(\"LONECARET\", \"(?:\\\\^)\"), i(\"CARETTRIM\", `(\\\\s*)${o[s.LONECARET]}\\\\s+`, !0), e.caretTrimReplace = \"$1^\", i(\"CARET\", `^${o[s.LONECARET]}${o[s.XRANGEPLAIN]}$`), i(\"CARETLOOSE\", `^${o[s.LONECARET]}${o[s.XRANGEPLAINLOOSE]}$`), i(\"COMPARATORLOOSE\", `^${o[s.GTLT]}\\\\s*(${o[s.LOOSEPLAIN]})$|^$`), i(\"COMPARATOR\", `^${o[s.GTLT]}\\\\s*(${o[s.FULLPLAIN]})$|^$`), i(\"COMPARATORTRIM\", `(\\\\s*)${o[s.GTLT]}\\\\s*(${o[s.LOOSEPLAIN]}|${o[s.XRANGEPLAIN]})`, !0), e.comparatorTrimReplace = \"$1$2$3\", i(\"HYPHENRANGE\", `^\\\\s*(${o[s.XRANGEPLAIN]})\\\\s+-\\\\s+(${o[s.XRANGEPLAIN]})\\\\s*$`), i(\"HYPHENRANGELOOSE\", `^\\\\s*(${o[s.XRANGEPLAINLOOSE]})\\\\s+-\\\\s+(${o[s.XRANGEPLAINLOOSE]})\\\\s*$`), i(\"STAR\", \"(<|>)?=?\\\\s*\\\\*\"), i(\"GTE0\", \"^\\\\s*>=\\\\s*0.0.0\\\\s*$\"), i(\"GTE0PRE\", \"^\\\\s*>=\\\\s*0.0.0-0\\\\s*$\");\n  }),\n  Je = /^[0-9]+$/,\n  ze = (n, e) => {\n    let t = Je.test(n),\n      r = Je.test(e);\n    return t && r && (n = +n, e = +e), n === e ? 0 : t && !r ? -1 : r && !t ? 1 : n < e ? -1 : 1;\n  },\n  Wt = (n, e) => ze(e, n),\n  Ut = {\n    compareIdentifiers: ze,\n    rcompareIdentifiers: Wt\n  },\n  {\n    MAX_LENGTH: Fe,\n    MAX_SAFE_INTEGER: se\n  } = we,\n  {\n    re: Ge,\n    t: Ke\n  } = Y,\n  {\n    compareIdentifiers: H\n  } = Ut,\n  f = class {\n    constructor(e, t) {\n      if (t && typeof t == \"object\" || (t = {\n        loose: !!t,\n        includePrerelease: !1\n      }), e instanceof f) {\n        if (e.loose === !!t.loose && e.includePrerelease === !!t.includePrerelease) return e;\n        e = e.version;\n      } else if (typeof e != \"string\") throw new TypeError(`Invalid Version: ${e}`);\n      if (e.length > Fe) throw new TypeError(`version is longer than ${Fe} characters`);\n      h(\"SemVer\", e, t), this.options = t, this.loose = !!t.loose, this.includePrerelease = !!t.includePrerelease;\n      let r = e.trim().match(t.loose ? Ge[Ke.LOOSE] : Ge[Ke.FULL]);\n      if (!r) throw new TypeError(`Invalid Version: ${e}`);\n      if (this.raw = e, this.major = +r[1], this.minor = +r[2], this.patch = +r[3], this.major > se || this.major < 0) throw new TypeError(\"Invalid major version\");\n      if (this.minor > se || this.minor < 0) throw new TypeError(\"Invalid minor version\");\n      if (this.patch > se || this.patch < 0) throw new TypeError(\"Invalid patch version\");\n      r[4] ? this.prerelease = r[4].split(\".\").map(o => {\n        if (/^[0-9]+$/.test(o)) {\n          let s = +o;\n          if (s >= 0 && s < se) return s;\n        }\n        return o;\n      }) : this.prerelease = [], this.build = r[5] ? r[5].split(\".\") : [], this.format();\n    }\n    format() {\n      return this.version = `${this.major}.${this.minor}.${this.patch}`, this.prerelease.length && (this.version += `-${this.prerelease.join(\".\")}`), this.version;\n    }\n    toString() {\n      return this.version;\n    }\n    compare(e) {\n      if (h(\"SemVer.compare\", this.version, this.options, e), !(e instanceof f)) {\n        if (typeof e == \"string\" && e === this.version) return 0;\n        e = new f(e, this.options);\n      }\n      return e.version === this.version ? 0 : this.compareMain(e) || this.comparePre(e);\n    }\n    compareMain(e) {\n      return e instanceof f || (e = new f(e, this.options)), H(this.major, e.major) || H(this.minor, e.minor) || H(this.patch, e.patch);\n    }\n    comparePre(e) {\n      if (e instanceof f || (e = new f(e, this.options)), this.prerelease.length && !e.prerelease.length) return -1;\n      if (!this.prerelease.length && e.prerelease.length) return 1;\n      if (!this.prerelease.length && !e.prerelease.length) return 0;\n      let t = 0;\n      do {\n        let r = this.prerelease[t],\n          o = e.prerelease[t];\n        if (h(\"prerelease compare\", t, r, o), r === void 0 && o === void 0) return 0;\n        if (o === void 0) return 1;\n        if (r === void 0) return -1;\n        if (r !== o) return H(r, o);\n      } while (++t);\n    }\n    compareBuild(e) {\n      e instanceof f || (e = new f(e, this.options));\n      let t = 0;\n      do {\n        let r = this.build[t],\n          o = e.build[t];\n        if (h(\"prerelease compare\", t, r, o), r === void 0 && o === void 0) return 0;\n        if (o === void 0) return 1;\n        if (r === void 0) return -1;\n        if (r !== o) return H(r, o);\n      } while (++t);\n    }\n    inc(e, t) {\n      switch (e) {\n        case \"premajor\":\n          this.prerelease.length = 0, this.patch = 0, this.minor = 0, this.major++, this.inc(\"pre\", t);\n          break;\n        case \"preminor\":\n          this.prerelease.length = 0, this.patch = 0, this.minor++, this.inc(\"pre\", t);\n          break;\n        case \"prepatch\":\n          this.prerelease.length = 0, this.inc(\"patch\", t), this.inc(\"pre\", t);\n          break;\n        case \"prerelease\":\n          this.prerelease.length === 0 && this.inc(\"patch\", t), this.inc(\"pre\", t);\n          break;\n        case \"major\":\n          this.minor === 0 && this.patch === 0 && this.prerelease.length !== 0 || this.major++, this.minor = 0, this.patch = 0, this.prerelease = [];\n          break;\n        case \"minor\":\n          this.patch === 0 && this.prerelease.length !== 0 || this.minor++, this.patch = 0, this.prerelease = [];\n          break;\n        case \"patch\":\n          this.prerelease.length === 0 && this.patch++, this.prerelease = [];\n          break;\n        case \"pre\":\n          if (this.prerelease.length === 0) this.prerelease = [0];else {\n            let r = this.prerelease.length;\n            for (; --r >= 0;) typeof this.prerelease[r] == \"number\" && (this.prerelease[r]++, r = -2);\n            r === -1 && this.prerelease.push(0);\n          }\n          t && (this.prerelease[0] === t ? isNaN(this.prerelease[1]) && (this.prerelease = [t, 0]) : this.prerelease = [t, 0]);\n          break;\n        default:\n          throw new Error(`invalid increment argument: ${e}`);\n      }\n      return this.format(), this.raw = this.version, this;\n    }\n  },\n  Jt = (n, e, t) => new f(n, t).compare(new f(e, t)),\n  G = Jt,\n  Ft = (n, e, t) => G(n, e, t) === 0,\n  Gt = Ft,\n  Kt = (n, e, t) => G(n, e, t) !== 0,\n  jt = Kt,\n  Bt = (n, e, t) => G(n, e, t) > 0,\n  Xt = Bt,\n  Vt = (n, e, t) => G(n, e, t) >= 0,\n  Ht = Vt,\n  zt = (n, e, t) => G(n, e, t) < 0,\n  Yt = zt,\n  Zt = (n, e, t) => G(n, e, t) <= 0,\n  Qt = Zt,\n  en = (n, e, t, r) => {\n    switch (e) {\n      case \"===\":\n        return typeof n == \"object\" && (n = n.version), typeof t == \"object\" && (t = t.version), n === t;\n      case \"!==\":\n        return typeof n == \"object\" && (n = n.version), typeof t == \"object\" && (t = t.version), n !== t;\n      case \"\":\n      case \"=\":\n      case \"==\":\n        return Gt(n, t, r);\n      case \"!=\":\n        return jt(n, t, r);\n      case \">\":\n        return Xt(n, t, r);\n      case \">=\":\n        return Ht(n, t, r);\n      case \"<\":\n        return Yt(n, t, r);\n      case \"<=\":\n        return Qt(n, t, r);\n      default:\n        throw new TypeError(`Invalid operator: ${e}`);\n    }\n  },\n  xe = en,\n  z = Symbol(\"SemVer ANY\"),\n  q = class {\n    static get ANY() {\n      return z;\n    }\n    constructor(e, t) {\n      if (t && typeof t == \"object\" || (t = {\n        loose: !!t,\n        includePrerelease: !1\n      }), e instanceof q) {\n        if (e.loose === !!t.loose) return e;\n        e = e.value;\n      }\n      h(\"comparator\", e, t), this.options = t, this.loose = !!t.loose, this.parse(e), this.semver === z ? this.value = \"\" : this.value = this.operator + this.semver.version, h(\"comp\", this);\n    }\n    parse(e) {\n      let t = this.options.loose ? je[Be.COMPARATORLOOSE] : je[Be.COMPARATOR],\n        r = e.match(t);\n      if (!r) throw new TypeError(`Invalid comparator: ${e}`);\n      this.operator = r[1] !== void 0 ? r[1] : \"\", this.operator === \"=\" && (this.operator = \"\"), r[2] ? this.semver = new f(r[2], this.options.loose) : this.semver = z;\n    }\n    toString() {\n      return this.value;\n    }\n    test(e) {\n      if (h(\"Comparator.test\", e, this.options.loose), this.semver === z || e === z) return !0;\n      if (typeof e == \"string\") try {\n        e = new f(e, this.options);\n      } catch (t) {\n        return !1;\n      }\n      return xe(e, this.operator, this.semver, this.options);\n    }\n    intersects(e, t) {\n      if (!(e instanceof q)) throw new TypeError(\"a Comparator is required\");\n      if (t && typeof t == \"object\" || (t = {\n        loose: !!t,\n        includePrerelease: !1\n      }), this.operator === \"\") return this.value === \"\" || new C(e.value, t).test(this.value);\n      if (e.operator === \"\") return e.value === \"\" || new C(this.value, t).test(e.semver);\n      let r = !(this.operator !== \">=\" && this.operator !== \">\" || e.operator !== \">=\" && e.operator !== \">\"),\n        o = !(this.operator !== \"<=\" && this.operator !== \"<\" || e.operator !== \"<=\" && e.operator !== \"<\"),\n        s = this.semver.version === e.semver.version,\n        a = !(this.operator !== \">=\" && this.operator !== \"<=\" || e.operator !== \">=\" && e.operator !== \"<=\"),\n        i = xe(this.semver, \"<\", e.semver, t) && (this.operator === \">=\" || this.operator === \">\") && (e.operator === \"<=\" || e.operator === \"<\"),\n        l = xe(this.semver, \">\", e.semver, t) && (this.operator === \"<=\" || this.operator === \"<\") && (e.operator === \">=\" || e.operator === \">\");\n      return r || o || s && a || i || l;\n    }\n  },\n  {\n    re: je,\n    t: Be\n  } = Y,\n  C = class {\n    constructor(e, t) {\n      if (t && typeof t == \"object\" || (t = {\n        loose: !!t,\n        includePrerelease: !1\n      }), e instanceof C) return e.loose === !!t.loose && e.includePrerelease === !!t.includePrerelease ? e : new C(e.raw, t);\n      if (e instanceof q) return this.raw = e.value, this.set = [[e]], this.format(), this;\n      if (this.options = t, this.loose = !!t.loose, this.includePrerelease = !!t.includePrerelease, this.raw = e, this.set = e.split(/\\s*\\|\\|\\s*/).map(r => this.parseRange(r.trim())).filter(r => r.length), !this.set.length) throw new TypeError(`Invalid SemVer Range: ${e}`);\n      this.format();\n    }\n    format() {\n      return this.range = this.set.map(e => e.join(\" \").trim()).join(\"||\").trim(), this.range;\n    }\n    toString() {\n      return this.range;\n    }\n    parseRange(e) {\n      let {\n        loose: t\n      } = this.options;\n      e = e.trim();\n      let r = t ? R[y.HYPHENRANGELOOSE] : R[y.HYPHENRANGE];\n      e = e.replace(r, hn(this.options.includePrerelease)), h(\"hyphen replace\", e), e = e.replace(R[y.COMPARATORTRIM], tn), h(\"comparator trim\", e, R[y.COMPARATORTRIM]), e = (e = (e = e.replace(R[y.TILDETRIM], nn)).replace(R[y.CARETTRIM], rn)).split(/\\s+/).join(\" \");\n      let o = t ? R[y.COMPARATORLOOSE] : R[y.COMPARATOR];\n      return e.split(\" \").map(s => sn(s, this.options)).join(\" \").split(/\\s+/).map(s => mn(s, this.options)).filter(this.options.loose ? s => !!s.match(o) : () => !0).map(s => new q(s, this.options));\n    }\n    intersects(e, t) {\n      if (!(e instanceof C)) throw new TypeError(\"a Range is required\");\n      return this.set.some(r => Xe(r, t) && e.set.some(o => Xe(o, t) && r.every(s => o.every(a => s.intersects(a, t)))));\n    }\n    test(e) {\n      if (!e) return !1;\n      if (typeof e == \"string\") try {\n        e = new f(e, this.options);\n      } catch (t) {\n        return !1;\n      }\n      for (let t = 0; t < this.set.length; t++) if (En(this.set[t], e, this.options)) return !0;\n      return !1;\n    }\n  },\n  {\n    re: R,\n    t: y,\n    comparatorTrimReplace: tn,\n    tildeTrimReplace: nn,\n    caretTrimReplace: rn\n  } = Y,\n  Xe = (n, e) => {\n    let t = !0,\n      r = n.slice(),\n      o = r.pop();\n    for (; t && r.length;) t = r.every(s => o.intersects(s, e)), o = r.pop();\n    return t;\n  },\n  sn = (n, e) => (h(\"comp\", n, e), n = ln(n, e), h(\"caret\", n), n = on(n, e), h(\"tildes\", n), n = un(n, e), h(\"xrange\", n), n = pn(n, e), h(\"stars\", n), n),\n  I = n => !n || n.toLowerCase() === \"x\" || n === \"*\",\n  on = (n, e) => n.trim().split(/\\s+/).map(t => an(t, e)).join(\" \"),\n  an = (n, e) => {\n    let t = e.loose ? R[y.TILDELOOSE] : R[y.TILDE];\n    return n.replace(t, (r, o, s, a, i) => {\n      let l;\n      return h(\"tilde\", n, r, o, s, a, i), I(o) ? l = \"\" : I(s) ? l = `>=${o}.0.0 <${+o + 1}.0.0-0` : I(a) ? l = `>=${o}.${s}.0 <${o}.${+s + 1}.0-0` : i ? (h(\"replaceTilde pr\", i), l = `>=${o}.${s}.${a}-${i} <${o}.${+s + 1}.0-0`) : l = `>=${o}.${s}.${a} <${o}.${+s + 1}.0-0`, h(\"tilde return\", l), l;\n    });\n  },\n  ln = (n, e) => n.trim().split(/\\s+/).map(t => cn(t, e)).join(\" \"),\n  cn = (n, e) => {\n    h(\"caret\", n, e);\n    let t = e.loose ? R[y.CARETLOOSE] : R[y.CARET],\n      r = e.includePrerelease ? \"-0\" : \"\";\n    return n.replace(t, (o, s, a, i, l) => {\n      let u;\n      return h(\"caret\", n, o, s, a, i, l), I(s) ? u = \"\" : I(a) ? u = `>=${s}.0.0${r} <${+s + 1}.0.0-0` : I(i) ? u = s === \"0\" ? `>=${s}.${a}.0${r} <${s}.${+a + 1}.0-0` : `>=${s}.${a}.0${r} <${+s + 1}.0.0-0` : l ? (h(\"replaceCaret pr\", l), u = s === \"0\" ? a === \"0\" ? `>=${s}.${a}.${i}-${l} <${s}.${a}.${+i + 1}-0` : `>=${s}.${a}.${i}-${l} <${s}.${+a + 1}.0-0` : `>=${s}.${a}.${i}-${l} <${+s + 1}.0.0-0`) : (h(\"no pr\"), u = s === \"0\" ? a === \"0\" ? `>=${s}.${a}.${i}${r} <${s}.${a}.${+i + 1}-0` : `>=${s}.${a}.${i}${r} <${s}.${+a + 1}.0-0` : `>=${s}.${a}.${i} <${+s + 1}.0.0-0`), h(\"caret return\", u), u;\n    });\n  },\n  un = (n, e) => (h(\"replaceXRanges\", n, e), n.split(/\\s+/).map(t => dn(t, e)).join(\" \")),\n  dn = (n, e) => {\n    n = n.trim();\n    let t = e.loose ? R[y.XRANGELOOSE] : R[y.XRANGE];\n    return n.replace(t, (r, o, s, a, i, l) => {\n      h(\"xRange\", n, r, o, s, a, i, l);\n      let u = I(s),\n        c = u || I(a),\n        d = c || I(i),\n        x = d;\n      return o === \"=\" && x && (o = \"\"), l = e.includePrerelease ? \"-0\" : \"\", u ? r = o === \">\" || o === \"<\" ? \"<0.0.0-0\" : \"*\" : o && x ? (c && (a = 0), i = 0, o === \">\" ? (o = \">=\", c ? (s = +s + 1, a = 0, i = 0) : (a = +a + 1, i = 0)) : o === \"<=\" && (o = \"<\", c ? s = +s + 1 : a = +a + 1), o === \"<\" && (l = \"-0\"), r = `${o + s}.${a}.${i}${l}`) : c ? r = `>=${s}.0.0${l} <${+s + 1}.0.0-0` : d && (r = `>=${s}.${a}.0${l} <${s}.${+a + 1}.0-0`), h(\"xRange return\", r), r;\n    });\n  },\n  pn = (n, e) => (h(\"replaceStars\", n, e), n.trim().replace(R[y.STAR], \"\")),\n  mn = (n, e) => (h(\"replaceGTE0\", n, e), n.trim().replace(R[e.includePrerelease ? y.GTE0PRE : y.GTE0], \"\")),\n  hn = n => (e, t, r, o, s, a, i, l, u, c, d, x, k) => `${t = I(r) ? \"\" : I(o) ? `>=${r}.0.0${n ? \"-0\" : \"\"}` : I(s) ? `>=${r}.${o}.0${n ? \"-0\" : \"\"}` : a ? `>=${t}` : `>=${t}${n ? \"-0\" : \"\"}`} ${l = I(u) ? \"\" : I(c) ? `<${+u + 1}.0.0-0` : I(d) ? `<${u}.${+c + 1}.0-0` : x ? `<=${u}.${c}.${d}-${x}` : n ? `<${u}.${c}.${+d + 1}-0` : `<=${l}`}`.trim(),\n  En = (n, e, t) => {\n    for (let r = 0; r < n.length; r++) if (!n[r].test(e)) return !1;\n    if (e.prerelease.length && !t.includePrerelease) {\n      for (let r = 0; r < n.length; r++) if (h(n[r].semver), n[r].semver !== q.ANY && n[r].semver.prerelease.length > 0) {\n        let o = n[r].semver;\n        if (o.major === e.major && o.minor === e.minor && o.patch === e.patch) return !0;\n      }\n      return !1;\n    }\n    return !0;\n  },\n  Ye = (n, e, t) => {\n    try {\n      e = new C(e, t);\n    } catch (r) {\n      return !1;\n    }\n    return e.test(n);\n  };\nvar {\n    MAX_LENGTH: fn\n  } = we,\n  {\n    re: Ve,\n    t: He\n  } = Y,\n  gn = (n, e) => {\n    if (e && typeof e == \"object\" || (e = {\n      loose: !!e,\n      includePrerelease: !1\n    }), n instanceof f) return n;\n    if (typeof n != \"string\" || n.length > fn || !(e.loose ? Ve[He.LOOSE] : Ve[He.FULL]).test(n)) return null;\n    try {\n      return new f(n, e);\n    } catch (t) {\n      return null;\n    }\n  },\n  yn = gn,\n  {\n    re: oe,\n    t: ie\n  } = Y,\n  Ze = (n, e) => {\n    if (n instanceof f) return n;\n    if (typeof n == \"number\" && (n = String(n)), typeof n != \"string\") return null;\n    let t = null;\n    if ((e = e || {}).rtl) {\n      let r;\n      for (; (r = oe[ie.COERCERTL].exec(n)) && (!t || t.index + t[0].length !== n.length);) t && r.index + r[0].length === t.index + t[0].length || (t = r), oe[ie.COERCERTL].lastIndex = r.index + r[1].length + r[2].length;\n      oe[ie.COERCERTL].lastIndex = -1;\n    } else t = n.match(oe[ie.COERCE]);\n    return t === null ? null : yn(`${t[2]}.${t[3] || \"0\"}.${t[4] || \"0\"}`, e);\n  };\nfunction Rn(n) {\n  return String.fromCharCode(parseInt(n.slice(1), 16));\n}\nfunction vn(n) {\n  return `%${`00${n.charCodeAt(0).toString(16)}`.slice(-2)}`;\n}\nfunction Tn(n) {\n  return btoa(encodeURIComponent(n).replace(/%[0-9A-F]{2}/g, Rn));\n}\nfunction In(n) {\n  return decodeURIComponent(Array.from(atob(n), vn).join(\"\"));\n}\nfunction ae(n) {\n  return Tn(JSON.stringify(n));\n}\nfunction Qe(n) {\n  return JSON.parse(In(n));\n}\nimport { RPCErrorCode as wn, SDKErrorCode as B, SDKWarningCode as ue } from \"@magic-sdk/types\";\nimport { MagicPayloadMethod as Pn, RPCErrorCode as bn } from \"@magic-sdk/types\";\nfunction S(n) {\n  return typeof n == \"undefined\";\n}\nfunction Mn(n) {\n  return n === null;\n}\nfunction le(n) {\n  return Mn(n) || S(n);\n}\nfunction lr(n) {\n  return le(n) ? !1 : !S(n.jsonrpc) && !S(n.id) && !S(n.method) && !S(n.params);\n}\nfunction et(n) {\n  return le(n) ? !1 : !S(n.jsonrpc) && !S(n.id) && (!S(n.result) || !S(n.error));\n}\nfunction cr(n) {\n  return le(n) ? !1 : typeof n == \"string\" && Object.values(Pn).includes(n);\n}\nfunction tt(n) {\n  return le(n) ? !1 : typeof n == \"number\" && Object.values(bn).includes(n);\n}\nfunction ce(n) {\n  if (!n) return !0;\n  for (let e in n) if (Object.hasOwnProperty.call(n, e)) return !1;\n  return !0;\n}\nvar m = {};\nfunction xn(n, e) {\n  return Object.assign(m, e), n;\n}\nvar nt = {\n  \"magic-sdk\": \"magic-sdk\",\n  \"@magic-sdk/react-native\": \"magic-sdk-rn\",\n  \"@magic-sdk/react-native-bare\": \"magic-sdk-rn-bare\",\n  \"@magic-sdk/react-native-expo\": \"magic-sdk-rn-expo\"\n};\nvar $ = class extends Error {\n    constructor(t, r) {\n      super(`Magic SDK Error: [${t}] ${r}`);\n      this.code = t;\n      this.rawMessage = r;\n      this.__proto__ = Error;\n      Object.setPrototypeOf(this, $.prototype);\n    }\n  },\n  L = class extends Error {\n    constructor(t) {\n      super();\n      this.__proto__ = Error;\n      let r = Number(t == null ? void 0 : t.code);\n      this.rawMessage = (t == null ? void 0 : t.message) || \"Internal error\", this.code = tt(r) ? r : wn.InternalError, this.message = `Magic RPC Error: [${this.code}] ${this.rawMessage}`, this.data = (t == null ? void 0 : t.data) || void 0, Object.setPrototypeOf(this, L.prototype);\n    }\n  },\n  K = class {\n    constructor(e, t) {\n      this.code = e;\n      this.rawMessage = t;\n      this.message = `Magic SDK Warning: [${e}] ${t}`;\n    }\n    log() {\n      console.warn(this.message);\n    }\n  },\n  j = class extends Error {\n    constructor(t, r, o, s) {\n      super(`Magic Extension Error (${t.name}): [${r}] ${o}`);\n      this.code = r;\n      this.rawMessage = o;\n      this.data = s;\n      this.__proto__ = Error;\n      Object.setPrototypeOf(this, j.prototype);\n    }\n  },\n  Z = class {\n    constructor(e, t, r) {\n      this.code = t;\n      this.rawMessage = r;\n      this.message = `Magic Extension Warning (${e.name}): [${t}] ${r}`;\n    }\n    log() {\n      console.warn(this.message);\n    }\n  };\nfunction rt() {\n  return new $(B.MissingApiKey, \"Please provide an API key that you acquired from the Magic developer dashboard.\");\n}\nfunction fr() {\n  return new $(B.ModalNotReady, \"Modal is not ready.\");\n}\nfunction st() {\n  return new $(B.MalformedResponse, \"Response from the Magic iframe is malformed.\");\n}\nfunction ot(n) {\n  return new $(B.ExtensionNotInitialized, `Extensions must be initialized with a Magic SDK instance before \\`Extension.${n}\\` can be accessed. Do not invoke \\`Extension.${n}\\` inside an extension constructor.`);\n}\nfunction it(n) {\n  let e = `Some extensions are incompatible with \\`${m.sdkName}@${m.version}\\`:`;\n  return n.filter(t => typeof t.compat != \"undefined\" && t.compat !== null).forEach(t => {\n    let r = t.compat[m.sdkName];\n    typeof r == \"string\" ? e += `\n  - Extension \\`${t.name}\\` supports version(s) \\`${r}\\`` : r || (e += `\n  - Extension \\`${t.name}\\` does not support ${m.platform} environments.`);\n  }), new $(B.IncompatibleExtensions, e);\n}\nfunction at(n) {\n  let e = t => {\n    let r = t + 1,\n      o = r % 10,\n      s = r % 100;\n    return o === 1 && s !== 11 ? `${r}st` : o === 2 && s !== 12 ? `${r}nd` : o === 3 && s !== 13 ? `${r}rd` : `${r}th`;\n  };\n  return new $(B.InvalidArgument, `Invalid ${e(n.argument)} argument given to \\`${n.procedure}\\`.\n  Expected: \\`${n.expected}\\`\n  Received: \\`${n.received}\\``);\n}\nfunction gr() {\n  return new K(ue.DuplicateIframe, \"Duplicate iframes found.\");\n}\nfunction lt() {\n  return new K(ue.SyncWeb3Method, \"Non-async web3 methods are deprecated in web3 > 1.0 and are not supported by the Magic web3 provider. Please use an async method instead.\");\n}\nfunction ct() {\n  return new K(ue.ReactNativeEndpointConfiguration, `CUSTOM DOMAINS ARE NOT SUPPORTED WHEN USING MAGIC SDK WITH REACT NATIVE! The \\`endpoint\\` parameter SHOULD NOT be provided. The Magic \\`<iframe>\\` is automatically wrapped by a WebView pointed at \\`${m.defaultEndpoint}\\`. Changing this default behavior will lead to unexpected results and potentially security-threatening bugs.`);\n}\nfunction v(n) {\n  let {\n      method: e,\n      removalVersions: t,\n      useInstead: r\n    } = n,\n    o = t[m.sdkName],\n    s = r ? ` Use \\`${r}\\` instead.` : \"\",\n    a = `\\`${e}\\` will be removed from \\`${m.sdkName}\\` in version \\`${o}\\`.${s}`;\n  return new K(ue.DeprecationNotice, a);\n}\nimport { MagicPayloadMethod as w } from \"@magic-sdk/types\";\nimport { MagicOutgoingWindowMessage as Ln, MagicIncomingWindowMessage as On, MagicPayloadMethod as _n } from \"@magic-sdk/types\";\nfunction* Nn() {\n  let n = 0;\n  for (;;) n < Number.MAX_SAFE_INTEGER ? yield ++n : n = 0;\n}\nvar $n = Nn();\nfunction Ne() {\n  return $n.next().value;\n}\nvar ut = Symbol(\"Payload pre-processed by Magic SDK\");\nfunction dt(n) {\n  return Object.defineProperty(n, ut, {\n    value: !0,\n    enumerable: !1\n  }), n;\n}\nfunction An(n) {\n  return !!n[ut];\n}\nfunction J(n) {\n  var e, t, r;\n  return An(n) || (n.jsonrpc = (e = n.jsonrpc) != null ? e : \"2.0\", n.id = Ne(), n.method = (t = n.method) != null ? t : \"noop\", n.params = (r = n.params) != null ? r : [], dt(n)), n;\n}\nfunction p(n) {\n  let e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n  return dt({\n    params: e,\n    method: n,\n    jsonrpc: \"2.0\",\n    id: Ne()\n  });\n}\nvar D = class {\n  constructor(e) {\n    e instanceof D ? (this._jsonrpc = e.payload.jsonrpc, this._id = e.payload.id, this._result = e.payload.result, this._error = e.payload.error) : et(e) ? (this._jsonrpc = e.jsonrpc, this._id = e.id, this._result = e.result, this._error = e.error) : (this._jsonrpc = e.jsonrpc, this._id = e.id, this._result = void 0, this._error = void 0);\n  }\n  applyError(e) {\n    return this._error = e, this;\n  }\n  applyResult(e) {\n    return this._result = e, this;\n  }\n  get hasError() {\n    return typeof this._error != \"undefined\" && this._error !== null;\n  }\n  get hasResult() {\n    return typeof this._result != \"undefined\";\n  }\n  get payload() {\n    return {\n      jsonrpc: this._jsonrpc,\n      id: this._id,\n      result: this._result,\n      error: this._error\n    };\n  }\n};\nvar ht = _t(mt()),\n  Ae = class extends ht.default {};\nfunction pe() {\n  let n = new Ae();\n  return {\n    emitter: n,\n    createChainingEmitterMethod: (r, o) => function () {\n      for (var _len2 = arguments.length, s = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        s[_key2] = arguments[_key2];\n      }\n      return n[r].apply(n, s), o;\n    },\n    createBoundEmitterMethod: r => function () {\n      for (var _len3 = arguments.length, o = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n        o[_key3] = arguments[_key3];\n      }\n      return n[r].apply(n, o);\n    }\n  };\n}\nvar Et = Symbol(\"isPromiEvent\");\nfunction ft(n) {\n  return !!n[Et];\n}\nfunction me(n) {\n  let e = Ce(n),\n    {\n      createBoundEmitterMethod: t,\n      createChainingEmitterMethod: r\n    } = pe(),\n    o = Symbol(\"Promise.then\"),\n    s = Symbol(\"Promise.catch\"),\n    a = Symbol(\"Promise.finally\"),\n    i = (c, d) => function () {\n      for (var _len4 = arguments.length, x = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n        x[_key4] = arguments[_key4];\n      }\n      let k = d[c].apply(d, x);\n      return l(k);\n    },\n    l = c => Object.assign(c, {\n      [Et]: !0,\n      [o]: c[o] || c.then,\n      [s]: c[s] || c.catch,\n      [a]: c[a] || c.finally,\n      then: i(o, c),\n      catch: i(s, c),\n      finally: i(a, c),\n      on: r(\"on\", c),\n      once: r(\"once\", c),\n      addListener: r(\"addListener\", c),\n      off: r(\"off\", c),\n      removeListener: r(\"removeListener\", c),\n      removeAllListeners: r(\"removeAllListeners\", c),\n      emit: t(\"emit\"),\n      eventNames: t(\"eventNames\"),\n      listeners: t(\"listeners\"),\n      listenerCount: t(\"listenerCount\")\n    }),\n    u = l(e.then(c => (u.emit(\"done\", c), u.emit(\"settled\"), c), c => {\n      throw u.emit(\"error\", c), u.emit(\"settled\"), c;\n    }));\n  return u;\n}\nfunction Ce(n) {\n  return new Promise((e, t) => {\n    let r = n(e, t);\n    Promise.resolve(r).catch(t);\n  });\n}\nvar b = class {\n  constructor(e) {\n    this.sdk = e;\n  }\n  get overlay() {\n    return this.sdk.overlay;\n  }\n  request(e) {\n    let t = this.overlay.post(Ln.MAGIC_HANDLE_REQUEST, J(e)),\n      r = me((s, a) => {\n        t.then(i => {\n          if (o(), i.hasError) a(new L(i.payload.error));else if (i.hasResult) s(i.payload.result);else throw st();\n        }).catch(i => {\n          o(), a(i);\n        });\n      }),\n      o = this.overlay.on(On.MAGIC_HANDLE_EVENT, s => {\n        var i;\n        let {\n          response: a\n        } = s.data;\n        if (a.id === e.id && ((i = a.result) == null ? void 0 : i.event)) {\n          let {\n            event: l,\n            params: u = []\n          } = a.result;\n          r.emit(l, ...u);\n        }\n      });\n    return r;\n  }\n  createIntermediaryEvent(e, t) {\n    return o => {\n      let s = p(_n.IntermediaryEvent, [{\n        payloadId: t,\n        eventType: e,\n        args: o\n      }]);\n      this.request(s);\n    };\n  }\n};\nvar M = {\n    \"magic-sdk\": \"v18.0.0\",\n    \"@magic-sdk/react-native\": \"v14.0.0\",\n    \"@magic-sdk/react-native-bare\": \"v19.0.0\",\n    \"@magic-sdk/react-native-expo\": \"v19.0.0\"\n  },\n  he = class extends b {\n    loginWithMagicLink(e) {\n      let t = m.sdkName === \"@magic-sdk/react-native\" || m.sdkName === \"@magic-sdk/react-native-bare\" || m.sdkName === \"@magic-sdk/react-native-expo\";\n      v({\n        method: \"auth.loginWithMagicLink()\",\n        removalVersions: M,\n        useInstead: t ? \"@magic-ext/auth auth.loginWithEmailOTP()\" : \"@magic-ext/auth auth.loginWithMagicLink()\"\n      }).log();\n      let {\n          email: r,\n          showUI: o = !0,\n          redirectURI: s\n        } = e,\n        a = p(this.sdk.testMode ? w.LoginWithMagicLinkTestMode : w.LoginWithMagicLink, [{\n          email: r,\n          showUI: o,\n          redirectURI: s\n        }]);\n      return this.request(a);\n    }\n    loginWithSMS(e) {\n      v({\n        method: \"auth.loginWithSMS()\",\n        removalVersions: M,\n        useInstead: \"@magic-ext/auth auth.loginWithSMS()\"\n      }).log();\n      let {\n          phoneNumber: t\n        } = e,\n        r = p(this.sdk.testMode ? w.LoginWithSmsTestMode : w.LoginWithSms, [{\n          phoneNumber: t,\n          showUI: !0\n        }]);\n      return this.request(r);\n    }\n    loginWithEmailOTP(e) {\n      v({\n        method: \"auth.loginWithEmailOTP()\",\n        removalVersions: M,\n        useInstead: \"@magic-ext/auth auth.loginWithEmailOTP()\"\n      }).log();\n      let {\n          email: t,\n          showUI: r\n        } = e,\n        o = p(this.sdk.testMode ? w.LoginWithEmailOTPTestMode : w.LoginWithEmailOTP, [{\n          email: t,\n          showUI: r\n        }]);\n      if (!r) {\n        let s = this.request(o);\n        return s && (s.on(\"verify-email-otp\", a => {\n          this.createIntermediaryEvent(\"verify-email-otp\", o.id)(a);\n        }), s.on(\"cancel\", () => {\n          this.createIntermediaryEvent(\"cancel\", o.id)();\n        })), s;\n      }\n      return this.request(o);\n    }\n    loginWithCredential(e) {\n      v({\n        method: \"auth.loginWithCredential()\",\n        removalVersions: M,\n        useInstead: \"@magic-ext/auth auth.loginWithCredential()\"\n      }).log();\n      let t = e != null ? e : \"\";\n      if (!e && m.platform === \"web\") {\n        t = window.location.search;\n        let o = window.location.origin + window.location.pathname;\n        window.history.replaceState(null, \"\", o);\n      }\n      let r = p(this.sdk.testMode ? w.LoginWithCredentialTestMode : w.LoginWithCredential, [t]);\n      return this.request(r);\n    }\n    setAuthorizationToken(e) {\n      v({\n        method: \"auth.setAuthorizationToken()\",\n        removalVersions: M,\n        useInstead: \"@magic-ext/auth auth.setAuthorizationToken()\"\n      }).log();\n      let t = p(w.SetAuthorizationToken, [{\n        jwt: e\n      }]);\n      return this.request(t);\n    }\n    updateEmailWithUI(e) {\n      v({\n        method: \"auth.updateEmailWithUI()\",\n        removalVersions: M,\n        useInstead: \"@magic-ext/auth auth.updateEmailWithUI()\"\n      }).log();\n      let {\n          email: t,\n          showUI: r = !0\n        } = e,\n        o = p(this.sdk.testMode ? w.UpdateEmailTestMode : w.UpdateEmail, [{\n          email: t,\n          showUI: r\n        }]);\n      return this.request(o);\n    }\n    updatePhoneNumberWithUI() {\n      v({\n        method: \"auth.updatePhoneNumberWithUI()\",\n        removalVersions: M,\n        useInstead: \"@magic-ext/auth auth.updatePhoneNumberWithUI()\"\n      }).log();\n      let e = p(this.sdk.testMode ? w.UpdatePhoneNumberTestMode : w.UpdatePhoneNumber);\n      return this.request(e);\n    }\n  };\nimport { MagicPayloadMethod as g } from \"@magic-sdk/types\";\nvar ee = {};\nLt(ee, {\n  clear: () => kn,\n  getItem: () => N,\n  iterate: () => Un,\n  key: () => Dn,\n  keys: () => Wn,\n  length: () => qn,\n  removeItem: () => U,\n  setItem: () => O\n});\nvar Ee;\nfunction W(n) {\n  var _this = this;\n  return function () {\n    for (var _len5 = arguments.length, e = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {\n      e[_key5] = arguments[_key5];\n    }\n    return E(_this, null, function* () {\n      return Ee || (Ee = yield m.configureStorage()), yield Ee.ready(), Ee[n](...e);\n    });\n  };\n}\nvar N = W(\"getItem\"),\n  O = W(\"setItem\"),\n  U = W(\"removeItem\"),\n  kn = W(\"clear\"),\n  qn = W(\"length\"),\n  Dn = W(\"key\"),\n  Wn = W(\"keys\"),\n  Un = W(\"iterate\");\nfunction gt() {\n  let n = window.crypto.getRandomValues(new Uint8Array(16));\n  n[6] = n[6] & 15 | 64, n[8] = n[8] & 191 | 128;\n  let e = \"\";\n  return e += n[0].toString(16), e += n[1].toString(16), e += n[2].toString(16), e += n[3].toString(16), e += \"-\", e += n[4].toString(16), e += n[5].toString(16), e += \"-\", e += n[6].toString(16), e += n[7].toString(16), e += \"-\", e += n[8].toString(16), e += n[9].toString(16), e += \"-\", e += n[10].toString(16), e += n[11].toString(16), e += n[12].toString(16), e += n[13].toString(16), e += n[14].toString(16), e += n[15].toString(16), e;\n}\nvar Se = \"STORE_KEY_PRIVATE_KEY\",\n  fe = \"STORE_KEY_PUBLIC_JWK\",\n  Le = \"ECDSA\",\n  Rt = \"P-256\",\n  Jn = {\n    name: Le,\n    namedCurve: Rt\n  },\n  Fn = {\n    name: Le,\n    namedCurve: Rt\n  };\nfunction ge() {\n  U(fe), U(Se);\n}\nfunction vt() {\n  return E(this, null, function* () {\n    let n = yield Gn();\n    if (!n) {\n      console.info(\"unable to create public key or webcrypto is unsupported\");\n      return;\n    }\n    let {\n        subtle: e\n      } = window.crypto,\n      t = yield N(Se);\n    if (!t || !e) {\n      console.info(\"unable to find private key or webcrypto unsupported\");\n      return;\n    }\n    let r = {\n        iat: Math.floor(new Date().getTime() / 1e3),\n        jti: gt()\n      },\n      o = {\n        typ: \"dpop+jwt\",\n        alg: \"ES256\",\n        jwk: n\n      },\n      s = {\n        protected: yt(JSON.stringify(o)),\n        claims: yt(JSON.stringify(r))\n      },\n      a = Bn(`${s.protected}.${s.claims}`),\n      i = {\n        name: Le,\n        hash: {\n          name: \"SHA-256\"\n        }\n      },\n      l = Vn(new Uint8Array(yield e.sign(i, t, a)));\n    return `${s.protected}.${s.claims}.${l}`;\n  });\n}\nfunction Gn() {\n  return E(this, null, function* () {\n    if (!jn()) {\n      console.info(\"webcrypto is not supported\");\n      return;\n    }\n    return (yield N(fe)) || (yield Kn()), N(fe);\n  });\n}\nfunction Kn() {\n  return E(this, null, function* () {\n    let n = null,\n      {\n        subtle: e\n      } = window.crypto,\n      t = yield e.generateKey(Jn, !0, [\"sign\"]),\n      r = yield e.exportKey(\"jwk\", t.privateKey);\n    n = yield e.exportKey(\"jwk\", t.publicKey);\n    let o = yield e.importKey(\"jwk\", r, Fn, !1, [\"sign\"]);\n    yield O(Se, o), yield O(fe, n);\n  });\n}\nfunction jn() {\n  let n = typeof window != \"undefined\" && !!window.crypto,\n    e = n && !!window.crypto.subtle;\n  return n && e;\n}\nfunction yt(n) {\n  return Tt(Xn(n));\n}\nfunction Bn(n) {\n  return new TextEncoder().encode(n);\n}\nfunction Tt(n) {\n  return btoa(n).replace(/\\+/g, \"-\").replace(/\\//g, \"_\").replace(/=+/g, \"\");\n}\nfunction Xn(n) {\n  return encodeURIComponent(n).replace(/%([0-9A-F]{2})/g, (t, r) => String.fromCharCode(parseInt(r, 16)));\n}\nfunction Vn(n) {\n  let e = \"\";\n  return n.forEach(t => {\n    e += String.fromCharCode(t);\n  }), Tt(e);\n}\nvar ye = class extends b {\n  constructor() {\n    super(...arguments);\n    this.localForageKey = \"mc_active_wallet\";\n  }\n  getIdToken(t) {\n    let r = p(this.sdk.testMode ? g.GetIdTokenTestMode : g.GetIdToken, [t]);\n    return this.request(r);\n  }\n  generateIdToken(t) {\n    let r = p(this.sdk.testMode ? g.GenerateIdTokenTestMode : g.GenerateIdToken, [t]);\n    return this.request(r);\n  }\n  getInfo() {\n    return E(this, null, function* () {\n      let t = yield N(this.localForageKey),\n        r = p(g.GetInfo, [{\n          walletType: t\n        }]);\n      return this.request(r);\n    });\n  }\n  isLoggedIn() {\n    let t = p(this.sdk.testMode ? g.IsLoggedInTestMode : g.IsLoggedIn);\n    return this.request(t);\n  }\n  logout() {\n    ge(), U(this.localForageKey);\n    let t = p(this.sdk.testMode ? g.LogoutTestMode : g.Logout);\n    return this.request(t);\n  }\n  requestInfoWithUI(t) {\n    let r = p(g.RequestUserInfoWithUI, t ? [t] : []);\n    return this.request(r);\n  }\n  showSettings(t) {\n    let r = p(this.sdk.testMode ? g.UserSettingsTestMode : g.UserSettings, [t]);\n    return this.request(r);\n  }\n  recoverAccount(t) {\n    let r = p(this.sdk.testMode ? g.RecoverAccountTestMode : g.RecoverAccount, [t]);\n    return this.request(r);\n  }\n  getMetadata() {\n    v({\n      method: \"user.getMetadata()\",\n      removalVersions: M,\n      useInstead: \"user.getInfo()\"\n    }).log();\n    let t = p(this.sdk.testMode ? g.GetMetadataTestMode : g.GetMetadata);\n    return this.request(t);\n  }\n  updateEmail(t) {\n    v({\n      method: \"user.updateEmail()\",\n      removalVersions: M,\n      useInstead: \"auth.updateEmailWithUI()\"\n    }).log();\n    let {\n        email: r,\n        showUI: o = !0\n      } = t,\n      s = p(this.sdk.testMode ? g.UpdateEmailTestMode : g.UpdateEmail, [{\n        email: r,\n        showUI: o\n      }]);\n    return this.request(s);\n  }\n  updatePhoneNumber() {\n    v({\n      method: \"user.updatePhoneNumber()\",\n      removalVersions: M,\n      useInstead: \"auth.updatePhoneNumberWithUI()\"\n    }).log();\n    let t = p(this.sdk.testMode ? g.UpdatePhoneNumberTestMode : g.UpdatePhoneNumber);\n    return this.request(t);\n  }\n};\nimport { Events as Oe, MagicPayloadMethod as X, Wallets as A } from \"@magic-sdk/types\";\nvar Re = class extends b {\n  constructor() {\n    super(...arguments);\n    this.localForageKey = \"mc_active_wallet\";\n  }\n  connectWithUI() {\n    return E(this, null, function* () {\n      if (this.isMetaMaskBrowser()) try {\n        if (yield this.isWalletEnabled(A.MetaMask)) return this.autoConnectIfWalletBrowser(A.MetaMask);\n      } catch (s) {\n        console.error(s);\n      }\n      if (this.isCoinbaseWalletBrowser()) try {\n        if (yield this.isWalletEnabled(A.CoinbaseWallet)) return this.autoConnectIfWalletBrowser(A.CoinbaseWallet);\n      } catch (s) {\n        console.error(s);\n      }\n      let t = this.getUserEnv(),\n        r = p(X.Login, [t]),\n        o = this.request(r);\n      return o.on(Oe.WalletSelected, s => this.handleWalletSelected(re(F({}, s), {\n        payloadId: r.id\n      }))), o;\n    });\n  }\n  showUI() {\n    let t = p(X.ShowUI);\n    return this.request(t);\n  }\n  getInfo() {\n    return E(this, null, function* () {\n      v({\n        method: \"wallet.getInfo()\",\n        removalVersions: M,\n        useInstead: \"user.getInfo()\"\n      }).log();\n      let t = yield N(this.localForageKey),\n        r = p(X.GetInfo, [{\n          walletType: t\n        }]);\n      return this.request(r);\n    });\n  }\n  disconnect() {\n    v({\n      method: \"wallet.disconnect()\",\n      removalVersions: M,\n      useInstead: \"user.logout()\"\n    }).log(), ge(), U(this.localForageKey);\n    let t = p(X.Disconnect);\n    return this.request(t);\n  }\n  requestUserInfoWithUI(t) {\n    v({\n      method: \"wallet.requestUserInfoWithUI()\",\n      removalVersions: M,\n      useInstead: \"user.requestUserInfoWithUI()\"\n    }).log();\n    let r = p(X.RequestUserInfoWithUI, t ? [t] : []);\n    return this.request(r);\n  }\n  getProvider() {\n    return E(this, null, function* () {\n      switch (yield N(this.localForageKey)) {\n        case A.MetaMask:\n          return this.getMetaMaskProvider();\n        case A.CoinbaseWallet:\n          return this.getCoinbaseProvider();\n        default:\n          return this.sdk.rpcProvider;\n      }\n    });\n  }\n  isMetaMaskInstalled() {\n    var t, r, o;\n    return ((t = window.ethereum) == null ? void 0 : t.isMetaMask) || !!((o = (r = window.ethereum) == null ? void 0 : r.providers) != null && o.find(s => s == null ? void 0 : s.isMetaMask));\n  }\n  isMetaMaskBrowser() {\n    return this.isMobile() && this.isMetaMaskInstalled();\n  }\n  getMetaMaskProvider() {\n    var t, r;\n    return ((r = (t = window.ethereum) == null ? void 0 : t.providers) == null ? void 0 : r.find(o => o == null ? void 0 : o.isMetaMask)) || window.ethereum;\n  }\n  connectToMetaMask() {\n    if (this.isMobile() && !this.isMetaMaskInstalled()) {\n      let t = `https://metamask.app.link/dapp/${window.location.href.replace(/(^\\w+:|^)\\/\\//, \"\")}`;\n      window.location.href = t;\n    }\n    return this.getMetaMaskProvider().request({\n      method: \"eth_requestAccounts\"\n    });\n  }\n  isCoinbaseWalletInstalled() {\n    var t, r, o;\n    return ((t = window.ethereum) == null ? void 0 : t.isCoinbaseWallet) || !!((o = (r = window.ethereum) == null ? void 0 : r.providers) != null && o.find(s => s == null ? void 0 : s.isCoinbaseWallet));\n  }\n  isCoinbaseWalletBrowser() {\n    var t;\n    return !!((t = window.ethereum) != null && t.isCoinbaseBrowser);\n  }\n  getCoinbaseProvider() {\n    var t, r;\n    return ((r = (t = window.ethereum) == null ? void 0 : t.providers) == null ? void 0 : r.find(o => o == null ? void 0 : o.isCoinbaseWallet)) || window.ethereum;\n  }\n  connectToCoinbaseWallet() {\n    if (this.isMobile() && !this.isCoinbaseWalletBrowser()) {\n      let r = `https://go.cb-w.com/dapp?cb_url=${encodeURIComponent(window.location.href)}`;\n      window.location.href = r;\n    }\n    return this.getCoinbaseProvider().request({\n      method: \"eth_requestAccounts\"\n    });\n  }\n  isMobile() {\n    return /Android|webOS|iPhone|iPad|iPod|BlackBerry|BB|PlayBook|IEMobile|Windows Phone|Silk|Opera Mini/i.test(navigator.userAgent);\n  }\n  getUserEnv() {\n    return {\n      env: {\n        isMetaMaskInstalled: this.isMetaMaskInstalled(),\n        isCoinbaseWalletInstalled: this.isCoinbaseWalletInstalled()\n      }\n    };\n  }\n  connectToThirdPartyWallet(t) {\n    switch (t) {\n      case A.MetaMask:\n        return this.connectToMetaMask();\n      case A.CoinbaseWallet:\n        return this.connectToCoinbaseWallet();\n      default:\n        throw new Error(`Invalid provider: ${t}. Must be one of \"metamask\" or \"coinbase_wallet\".`);\n    }\n  }\n  isWalletEnabled(t) {\n    let r = p(\"mc_is_wallet_enabled\", [{\n      wallet: t\n    }]);\n    return this.request(r);\n  }\n  handleWalletSelected(t) {\n    return E(this, null, function* () {\n      try {\n        let r = yield this.connectToThirdPartyWallet(t.wallet);\n        yield O(this.localForageKey, t.wallet), this.createIntermediaryEvent(Oe.WalletConnected, t.payloadId)(r);\n      } catch (r) {\n        console.error(r), this.createIntermediaryEvent(Oe.WalletRejected, t.payloadId)();\n      }\n    });\n  }\n  autoConnectIfWalletBrowser(t) {\n    return E(this, null, function* () {\n      let r;\n      t === A.MetaMask && (r = yield this.getMetaMaskProvider().request({\n        method: \"eth_requestAccounts\"\n      })), t === A.CoinbaseWallet && (r = yield this.getCoinbaseProvider().request({\n        method: \"eth_requestAccounts\"\n      })), yield O(this.localForageKey, t);\n      let o = p(X.AutoConnect, [{\n        wallet: t,\n        address: r\n      }]);\n      return this.request(o);\n    });\n  }\n};\nimport { MagicOutgoingWindowMessage as It } from \"@magic-sdk/types\";\nvar {\n    createBoundEmitterMethod: ve,\n    createChainingEmitterMethod: V\n  } = pe(),\n  Te = class extends b {\n    constructor() {\n      super(...arguments);\n      this.isMagic = !0;\n      this.on = V(\"on\", this);\n      this.once = V(\"once\", this);\n      this.addListener = V(\"addListener\", this);\n      this.off = V(\"off\", this);\n      this.removeListener = V(\"removeListener\", this);\n      this.removeAllListeners = V(\"removeAllListeners\", this);\n      this.emit = ve(\"emit\");\n      this.eventNames = ve(\"eventNames\");\n      this.listeners = ve(\"listeners\");\n      this.listenerCount = ve(\"listenerCount\");\n    }\n    sendAsync(t, r) {\n      if (!r) throw at({\n        procedure: \"Magic.rpcProvider.sendAsync\",\n        argument: 1,\n        expected: \"function\",\n        received: r === null ? \"null\" : typeof r\n      });\n      if (Array.isArray(t)) this.overlay.post(It.MAGIC_HANDLE_REQUEST, t.map(o => {\n        let s = J(o);\n        return this.prefixPayloadMethodForTestMode(s), s;\n      })).then(o => {\n        r(null, o.map(s => re(F({}, s.payload), {\n          error: s.hasError ? new L(s.payload.error) : null\n        })));\n      });else {\n        let o = J(t);\n        this.prefixPayloadMethodForTestMode(o), this.overlay.post(It.MAGIC_HANDLE_REQUEST, o).then(s => {\n          r(s.hasError ? new L(s.payload.error) : null, s.payload);\n        });\n      }\n    }\n    send(t, r) {\n      if (typeof t == \"string\") {\n        let s = p(t, Array.isArray(r) ? r : []);\n        return this.request(s);\n      }\n      if (Array.isArray(t) || !!r) {\n        this.sendAsync(t, r);\n        return;\n      }\n      let o = lt();\n      return o.log(), new D(t).applyError({\n        code: -32603,\n        message: o.rawMessage\n      }).payload;\n    }\n    enable() {\n      let t = p(\"eth_accounts\");\n      return this.request(t);\n    }\n    request(t) {\n      return this.prefixPayloadMethodForTestMode(t), super.request(t);\n    }\n    prefixPayloadMethodForTestMode(t) {\n      let r = \"testMode/eth/\";\n      this.sdk.testMode && (t.method = `${r}${t.method}`);\n    }\n  };\nfunction _e(n, e) {\n  return e ? new URL(n, e) : new URL(n);\n}\nvar Pt = [\"request\", \"overlay\", \"sdk\"];\nfunction Hn(n) {\n  let e = Object.getPrototypeOf(n),\n    t = [e];\n  for (; e !== b.prototype;) e = Object.getPrototypeOf(e), t.push(e);\n  return t;\n}\nvar Ie = class extends b {\n    constructor() {\n      super(void 0);\n      this.__sdk_access_field_descriptors__ = new Map();\n      this.__is_initialized__ = !1;\n      this.utils = {\n        createPromiEvent: me,\n        isPromiEvent: ft,\n        encodeJSON: ae,\n        decodeJSON: Qe,\n        createJsonRpcRequestPayload: p,\n        standardizeJsonRpcRequestPayload: J,\n        storage: ee\n      };\n      let t = [this, ...Hn(this)];\n      Pt.forEach(r => {\n        let o = t.map(l => Object.getOwnPropertyDescriptor(l, r)),\n          s = o.findIndex(l => !!l),\n          a = s > 0,\n          i = o[s];\n        i && (this.__sdk_access_field_descriptors__.set(r, {\n          descriptor: i,\n          isPrototypeField: a\n        }), Object.defineProperty(this, r, {\n          configurable: !0,\n          get: () => {\n            throw ot(r);\n          }\n        }));\n      });\n    }\n    init(t) {\n      this.__is_initialized__ || (Pt.forEach(r => {\n        if (this.__sdk_access_field_descriptors__.has(r)) {\n          let {\n            descriptor: o,\n            isPrototypeField: s\n          } = this.__sdk_access_field_descriptors__.get(r);\n          s ? delete this[r] : Object.defineProperty(this, r, o);\n        }\n      }), this.sdk = t, this.__is_initialized__ = !0);\n    }\n    createDeprecationWarning(t) {\n      let {\n          method: r,\n          removalVersion: o,\n          useInstead: s\n        } = t,\n        a = s ? ` Use \\`${s}\\` instead.` : \"\",\n        i = `\\`${r}\\` will be removed from this Extension in version \\`${o}\\`.${a}`;\n      return new Z(this, \"DEPRECATION_NOTICE\", i);\n    }\n    createWarning(t, r) {\n      return new Z(this, t, r);\n    }\n    createError(t, r, o) {\n      return new j(this, t, r, o);\n    }\n  },\n  ke = class extends Ie {},\n  _ = class extends Ie {};\n_.Internal = ke, _.Anonymous = \"anonymous extension\";\nimport { MagicPayloadMethod as zn } from \"@magic-sdk/types\";\nvar Pe = class extends b {\n  purchase(e) {\n    let t = p(zn.NFTPurchase, [e]);\n    return this.request(t);\n  }\n};\nfunction bt(n) {\n  return n.compat && n.compat[m.sdkName] != null ? typeof n.compat[m.sdkName] == \"string\" ? Ye(Ze(m.version), n.compat[m.sdkName]) : !!n.compat[m.sdkName] : !0;\n}\nfunction Yn(n) {\n  var o;\n  let e = (o = n == null ? void 0 : n.extensions) != null ? o : [],\n    t = {},\n    r = [];\n  if (Array.isArray(e) ? e.forEach(s => {\n    bt(s) ? (s.init(this), (s.name || s.name !== _.Anonymous) && (this[s.name] = s), s instanceof _.Internal && (ce(s.config) || (t[s.name] = s.config))) : r.push(s);\n  }) : Object.keys(e).forEach(s => {\n    if (bt(e[s])) {\n      e[s].init(this);\n      let a = e[s];\n      this[s] = a, a instanceof _.Internal && (ce(a.config) || (t[e[s].name] = a.config));\n    } else r.push(e[s]);\n  }), r.length) throw it(r);\n  return t;\n}\nvar te = class {\n    constructor(e, t) {\n      this.apiKey = e;\n      var a;\n      if (!e) throw rt();\n      m.platform === \"react-native\" && (t == null ? void 0 : t.endpoint) && ct().log();\n      let {\n        defaultEndpoint: r,\n        version: o\n      } = m;\n      this.testMode = !!(t != null && t.testMode), this.endpoint = _e((a = t == null ? void 0 : t.endpoint) != null ? a : r).origin, this.auth = new he(this), this.user = new ye(this), this.wallet = new Re(this), this.nft = new Pe(this), this.rpcProvider = new Te(this);\n      let s = Yn.call(this, t);\n      this.parameters = ae(F({\n        API_KEY: this.apiKey,\n        DOMAIN_ORIGIN: window.location ? window.location.origin : \"\",\n        ETH_NETWORK: t == null ? void 0 : t.network,\n        host: _e(this.endpoint).host,\n        sdk: nt[m.sdkName],\n        version: o,\n        ext: ce(s) ? void 0 : s,\n        locale: (t == null ? void 0 : t.locale) || \"en_US\"\n      }, m.bundleId ? {\n        bundleId: m.bundleId\n      } : {}));\n    }\n    get overlay() {\n      if (!te.__overlays__.has(this.parameters)) {\n        let e = new m.ViewController(this.endpoint, this.parameters);\n        e.init(), te.__overlays__.set(this.parameters, e);\n      }\n      return te.__overlays__.get(this.parameters);\n    }\n    preload() {\n      return E(this, null, function* () {\n        yield this.overlay.ready;\n      });\n    }\n  },\n  be = te;\nbe.__overlays__ = new Map();\nimport { MagicIncomingWindowMessage as Me } from \"@magic-sdk/types\";\nfunction Zn(n, e) {\n  return e && Array.isArray(n) ? n.find(t => t.id === e) : n;\n}\nfunction Qn(n, e) {\n  var o;\n  let t = (o = e.data.response) == null ? void 0 : o.id,\n    r = Zn(n, t);\n  if (t && r) {\n    let s = new D(r).applyResult(e.data.response.result).applyError(e.data.response.error);\n    return {\n      id: t,\n      response: s\n    };\n  }\n  return {};\n}\nfunction er(n, e) {\n  return E(this, null, function* () {\n    let t = yield N(\"rt\"),\n      r;\n    if (m.platform === \"web\") try {\n      r = yield vt();\n    } catch (o) {\n      console.error(\"webcrypto error\", o);\n    }\n    return r ? t ? {\n      msgType: n,\n      payload: e,\n      jwt: r,\n      rt: t\n    } : {\n      msgType: n,\n      payload: e,\n      jwt: r\n    } : {\n      msgType: n,\n      payload: e\n    };\n  });\n}\nfunction tr(n) {\n  return E(this, null, function* () {\n    !n.data.rt || (yield O(\"rt\", n.data.rt));\n  });\n}\nvar qe = class {\n  constructor(e, t) {\n    this.endpoint = e;\n    this.parameters = t;\n    this.messageHandlers = new Set();\n    this.ready = this.waitForReady(), this.listen();\n  }\n  post(e, t) {\n    return E(this, null, function* () {\n      return Ce(r => E(this, null, function* () {\n        yield this.ready;\n        let o = [],\n          s = Array.isArray(t) ? t.map(u => u.id) : [],\n          a = yield er(`${e}-${this.parameters}`, t);\n        yield this._post(a);\n        let i = u => c => {\n            let {\n              id: d,\n              response: x\n            } = Qn(t, c);\n            tr(c), d && x && Array.isArray(t) && s.includes(d) ? (o.push(x), o.length === t.length && (u(), r(o))) : d && x && !Array.isArray(t) && d === t.id && (u(), r(x));\n          },\n          l = this.on(Me.MAGIC_HANDLE_RESPONSE, i(() => l()));\n      }));\n    });\n  }\n  on(e, t) {\n    let r = t.bind(window),\n      o = s => {\n        s.data.msgType === `${e}-${this.parameters}` && r(s);\n      };\n    return this.messageHandlers.add(o), () => this.messageHandlers.delete(o);\n  }\n  waitForReady() {\n    return new Promise(e => {\n      this.on(Me.MAGIC_OVERLAY_READY, () => e());\n    });\n  }\n  listen() {\n    this.on(Me.MAGIC_HIDE_OVERLAY, () => {\n      this.hideOverlay();\n    }), this.on(Me.MAGIC_SHOW_OVERLAY, () => {\n      this.showOverlay();\n    });\n  }\n};\nexport { _ as Extension, j as MagicExtensionError, Z as MagicExtensionWarning, L as MagicRPCError, $ as MagicSDKError, K as MagicSDKWarning, be as SDKBase, Se as STORE_KEY_PRIVATE_KEY, fe as STORE_KEY_PUBLIC_JWK, Ae as TypedEmitter, qe as ViewController, ge as clearKeys, v as createDeprecationWarning, gr as createDuplicateIframeWarning, ot as createExtensionNotInitializedError, it as createIncompatibleExtensionsError, at as createInvalidArgumentError, vt as createJwt, st as createMalformedResponseError, rt as createMissingApiKeyError, fr as createModalNotReadyError, me as createPromiEvent, Ce as createPromise, ct as createReactNativeEndpointConfigurationWarning, xn as createSDK, lt as createSynchronousWeb3MethodWarning, pe as createTypedEmitter, _e as createURL, Qe as decodeJSON, ae as encodeJSON, Ne as getPayloadId, ce as isEmpty, tt as isJsonRpcErrorCode, lr as isJsonRpcRequestPayload, et as isJsonRpcResponsePayload, cr as isMagicPayloadMethod, ft as isPromiEvent, ee as storage, gt as uuid };\n//# sourceMappingURL=index.mjs.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}