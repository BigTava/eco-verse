{"ast":null,"code":"import I, { createContext as X, createRef as ue, useContext as Y, useEffect as q, useMemo as D, useReducer as me, useRef as V, useState as ie } from \"react\";\nimport { match as _ } from '../../utils/match.js';\nimport { forwardRefWithAs as $, render as J, Features as z } from '../../utils/render.js';\nimport { optionalRef as ye, useSyncRefs as U } from '../../hooks/use-sync-refs.js';\nimport { useId as K } from '../../hooks/use-id.js';\nimport { Keys as k } from '../keyboard.js';\nimport { isDisabledReactIssue7711 as fe } from '../../utils/bugs.js';\nimport { getFocusableElements as ee, Focus as h, focusIn as w, isFocusableElement as Ee, FocusableMode as ge, FocusResult as te } from '../../utils/focus-management.js';\nimport { OpenClosedProvider as be, State as W, useOpenClosed as Pe } from '../../internal/open-closed.js';\nimport { useResolveButtonType as Se } from '../../hooks/use-resolve-button-type.js';\nimport { useOutsideClick as Ae } from '../../hooks/use-outside-click.js';\nimport { getOwnerDocument as Re } from '../../utils/owner.js';\nimport { useOwnerDocument as oe } from '../../hooks/use-owner.js';\nimport { useEventListener as Oe } from '../../hooks/use-event-listener.js';\nimport { Hidden as re, Features as ne } from '../../internal/hidden.js';\nimport { useEvent as b } from '../../hooks/use-event.js';\nimport { useTabDirection as de, Direction as H } from '../../hooks/use-tab-direction.js';\nimport '../../utils/micro-task.js';\nimport { useLatestValue as ce } from '../../hooks/use-latest-value.js';\nimport { useIsoMorphicEffect as Ce } from '../../hooks/use-iso-morphic-effect.js';\nvar Fe = (s => (s[s.Open = 0] = \"Open\", s[s.Closed = 1] = \"Closed\", s))(Fe || {}),\n  Ie = (t => (t[t.TogglePopover = 0] = \"TogglePopover\", t[t.ClosePopover = 1] = \"ClosePopover\", t[t.SetButton = 2] = \"SetButton\", t[t.SetButtonId = 3] = \"SetButtonId\", t[t.SetPanel = 4] = \"SetPanel\", t[t.SetPanelId = 5] = \"SetPanelId\", t))(Ie || {});\nlet xe = {\n    [0]: o => ({\n      ...o,\n      popoverState: _(o.popoverState, {\n        [0]: 1,\n        [1]: 0\n      })\n    }),\n    [1](o) {\n      return o.popoverState === 1 ? o : {\n        ...o,\n        popoverState: 1\n      };\n    },\n    [2](o, l) {\n      return o.button === l.button ? o : {\n        ...o,\n        button: l.button\n      };\n    },\n    [3](o, l) {\n      return o.buttonId === l.buttonId ? o : {\n        ...o,\n        buttonId: l.buttonId\n      };\n    },\n    [4](o, l) {\n      return o.panel === l.panel ? o : {\n        ...o,\n        panel: l.panel\n      };\n    },\n    [5](o, l) {\n      return o.panelId === l.panelId ? o : {\n        ...o,\n        panelId: l.panelId\n      };\n    }\n  },\n  le = X(null);\nle.displayName = \"PopoverContext\";\nfunction Q(o) {\n  let l = Y(le);\n  if (l === null) {\n    let s = new Error(`<${o} /> is missing a parent <Popover /> component.`);\n    throw Error.captureStackTrace && Error.captureStackTrace(s, Q), s;\n  }\n  return l;\n}\nlet ae = X(null);\nae.displayName = \"PopoverAPIContext\";\nfunction pe(o) {\n  let l = Y(ae);\n  if (l === null) {\n    let s = new Error(`<${o} /> is missing a parent <Popover /> component.`);\n    throw Error.captureStackTrace && Error.captureStackTrace(s, pe), s;\n  }\n  return l;\n}\nlet se = X(null);\nse.displayName = \"PopoverGroupContext\";\nfunction ve() {\n  return Y(se);\n}\nlet Z = X(null);\nZ.displayName = \"PopoverPanelContext\";\nfunction Le() {\n  return Y(Z);\n}\nfunction Me(o, l) {\n  return _(l.type, xe, o, l);\n}\nlet Be = \"div\";\nfunction De(o, l) {\n  var B;\n  let s = V(null),\n    R = U(l, ye(e => {\n      s.current = e;\n    })),\n    C = V([]),\n    r = me(Me, {\n      popoverState: 1,\n      buttons: C,\n      button: null,\n      buttonId: null,\n      panel: null,\n      panelId: null,\n      beforePanelSentinel: ue(),\n      afterPanelSentinel: ue()\n    }),\n    [{\n      popoverState: t,\n      button: a,\n      buttonId: v,\n      panel: f,\n      panelId: F,\n      beforePanelSentinel: T,\n      afterPanelSentinel: d\n    }, i] = r,\n    p = oe((B = s.current) != null ? B : a),\n    P = D(() => {\n      if (!a || !f) return !1;\n      for (let N of document.querySelectorAll(\"body > *\")) if (Number(N == null ? void 0 : N.contains(a)) ^ Number(N == null ? void 0 : N.contains(f))) return !0;\n      let e = ee(),\n        n = e.indexOf(a),\n        A = (n + e.length - 1) % e.length,\n        g = (n + 1) % e.length,\n        G = e[A],\n        Te = e[g];\n      return !f.contains(G) && !f.contains(Te);\n    }, [a, f]),\n    S = ce(v),\n    y = ce(F),\n    x = D(() => ({\n      buttonId: S,\n      panelId: y,\n      close: () => i({\n        type: 1\n      })\n    }), [S, y, i]),\n    O = ve(),\n    L = O == null ? void 0 : O.registerPopover,\n    j = b(() => {\n      var e;\n      return (e = O == null ? void 0 : O.isFocusWithinPopoverGroup()) != null ? e : (p == null ? void 0 : p.activeElement) && ((a == null ? void 0 : a.contains(p.activeElement)) || (f == null ? void 0 : f.contains(p.activeElement)));\n    });\n  q(() => L == null ? void 0 : L(x), [L, x]), Oe(p == null ? void 0 : p.defaultView, \"focus\", e => {\n    var n, A, g, G;\n    t === 0 && (j() || a && f && e.target !== window && ((A = (n = T.current) == null ? void 0 : n.contains) != null && A.call(n, e.target) || (G = (g = d.current) == null ? void 0 : g.contains) != null && G.call(g, e.target) || i({\n      type: 1\n    })));\n  }, !0), Ae([a, f], (e, n) => {\n    i({\n      type: 1\n    }), Ee(n, ge.Loose) || (e.preventDefault(), a == null || a.focus());\n  }, t === 0);\n  let M = b(e => {\n      i({\n        type: 1\n      });\n      let n = (() => e ? e instanceof HTMLElement ? e : \"current\" in e && e.current instanceof HTMLElement ? e.current : a : a)();\n      n == null || n.focus();\n    }),\n    u = D(() => ({\n      close: M,\n      isPortalled: P\n    }), [M, P]),\n    m = D(() => ({\n      open: t === 0,\n      close: M\n    }), [t, M]),\n    E = o,\n    c = {\n      ref: R\n    };\n  return I.createElement(Z.Provider, {\n    value: null\n  }, I.createElement(le.Provider, {\n    value: r\n  }, I.createElement(ae.Provider, {\n    value: u\n  }, I.createElement(be, {\n    value: _(t, {\n      [0]: W.Open,\n      [1]: W.Closed\n    })\n  }, J({\n    ourProps: c,\n    theirProps: E,\n    slot: m,\n    defaultTag: Be,\n    name: \"Popover\"\n  })))));\n}\nlet he = \"button\";\nfunction He(o, l) {\n  let s = K(),\n    {\n      id: R = `headlessui-popover-button-${s}`,\n      ...C\n    } = o,\n    [r, t] = Q(\"Popover.Button\"),\n    {\n      isPortalled: a\n    } = pe(\"Popover.Button\"),\n    v = V(null),\n    f = `headlessui-focus-sentinel-${K()}`,\n    F = ve(),\n    T = F == null ? void 0 : F.closeOthers,\n    i = Le() !== null;\n  q(() => {\n    if (!i) return t({\n      type: 3,\n      buttonId: R\n    }), () => {\n      t({\n        type: 3,\n        buttonId: null\n      });\n    };\n  }, [i, R, t]);\n  let [p] = ie(() => Symbol()),\n    P = U(v, l, i ? null : e => {\n      if (e) r.buttons.current.push(p);else {\n        let n = r.buttons.current.indexOf(p);\n        n !== -1 && r.buttons.current.splice(n, 1);\n      }\n      r.buttons.current.length > 1 && console.warn(\"You are already using a <Popover.Button /> but only 1 <Popover.Button /> is supported.\"), e && t({\n        type: 2,\n        button: e\n      });\n    }),\n    S = U(v, l),\n    y = oe(v),\n    x = b(e => {\n      var n, A, g;\n      if (i) {\n        if (r.popoverState === 1) return;\n        switch (e.key) {\n          case k.Space:\n          case k.Enter:\n            e.preventDefault(), (A = (n = e.target).click) == null || A.call(n), t({\n              type: 1\n            }), (g = r.button) == null || g.focus();\n            break;\n        }\n      } else switch (e.key) {\n        case k.Space:\n        case k.Enter:\n          e.preventDefault(), e.stopPropagation(), r.popoverState === 1 && (T == null || T(r.buttonId)), t({\n            type: 0\n          });\n          break;\n        case k.Escape:\n          if (r.popoverState !== 0) return T == null ? void 0 : T(r.buttonId);\n          if (!v.current || y != null && y.activeElement && !v.current.contains(y.activeElement)) return;\n          e.preventDefault(), e.stopPropagation(), t({\n            type: 1\n          });\n          break;\n      }\n    }),\n    O = b(e => {\n      i || e.key === k.Space && e.preventDefault();\n    }),\n    L = b(e => {\n      var n, A;\n      fe(e.currentTarget) || o.disabled || (i ? (t({\n        type: 1\n      }), (n = r.button) == null || n.focus()) : (e.preventDefault(), e.stopPropagation(), r.popoverState === 1 && (T == null || T(r.buttonId)), t({\n        type: 0\n      }), (A = r.button) == null || A.focus()));\n    }),\n    j = b(e => {\n      e.preventDefault(), e.stopPropagation();\n    }),\n    M = r.popoverState === 0,\n    u = D(() => ({\n      open: M\n    }), [M]),\n    m = Se(o, v),\n    E = i ? {\n      ref: S,\n      type: m,\n      onKeyDown: x,\n      onClick: L\n    } : {\n      ref: P,\n      id: r.buttonId,\n      type: m,\n      \"aria-expanded\": o.disabled ? void 0 : r.popoverState === 0,\n      \"aria-controls\": r.panel ? r.panelId : void 0,\n      onKeyDown: x,\n      onKeyUp: O,\n      onClick: L,\n      onMouseDown: j\n    },\n    c = de(),\n    B = b(() => {\n      let e = r.panel;\n      if (!e) return;\n      function n() {\n        _(c.current, {\n          [H.Forwards]: () => w(e, h.First),\n          [H.Backwards]: () => w(e, h.Last)\n        }) === te.Error && w(ee().filter(g => g.dataset.headlessuiFocusGuard !== \"true\"), _(c.current, {\n          [H.Forwards]: h.Next,\n          [H.Backwards]: h.Previous\n        }), {\n          relativeTo: r.button\n        });\n      }\n      n();\n    });\n  return I.createElement(I.Fragment, null, J({\n    ourProps: E,\n    theirProps: C,\n    slot: u,\n    defaultTag: he,\n    name: \"Popover.Button\"\n  }), M && !i && a && I.createElement(re, {\n    id: f,\n    features: ne.Focusable,\n    \"data-headlessui-focus-guard\": !0,\n    as: \"button\",\n    type: \"button\",\n    onFocus: B\n  }));\n}\nlet Ge = \"div\",\n  _e = z.RenderStrategy | z.Static;\nfunction ke(o, l) {\n  let s = K(),\n    {\n      id: R = `headlessui-popover-overlay-${s}`,\n      ...C\n    } = o,\n    [{\n      popoverState: r\n    }, t] = Q(\"Popover.Overlay\"),\n    a = U(l),\n    v = Pe(),\n    f = (() => v !== null ? (v & W.Open) === W.Open : r === 0)(),\n    F = b(i => {\n      if (fe(i.currentTarget)) return i.preventDefault();\n      t({\n        type: 1\n      });\n    }),\n    T = D(() => ({\n      open: r === 0\n    }), [r]);\n  return J({\n    ourProps: {\n      ref: a,\n      id: R,\n      \"aria-hidden\": !0,\n      onClick: F\n    },\n    theirProps: C,\n    slot: T,\n    defaultTag: Ge,\n    features: _e,\n    visible: f,\n    name: \"Popover.Overlay\"\n  });\n}\nlet we = \"div\",\n  Ne = z.RenderStrategy | z.Static;\nfunction Ue(o, l) {\n  let s = K(),\n    {\n      id: R = `headlessui-popover-panel-${s}`,\n      focus: C = !1,\n      ...r\n    } = o,\n    [t, a] = Q(\"Popover.Panel\"),\n    {\n      close: v,\n      isPortalled: f\n    } = pe(\"Popover.Panel\"),\n    F = `headlessui-focus-sentinel-before-${K()}`,\n    T = `headlessui-focus-sentinel-after-${K()}`,\n    d = V(null),\n    i = U(d, l, u => {\n      a({\n        type: 4,\n        panel: u\n      });\n    }),\n    p = oe(d);\n  Ce(() => (a({\n    type: 5,\n    panelId: R\n  }), () => {\n    a({\n      type: 5,\n      panelId: null\n    });\n  }), [R, a]);\n  let P = Pe(),\n    S = (() => P !== null ? (P & W.Open) === W.Open : t.popoverState === 0)(),\n    y = b(u => {\n      var m;\n      switch (u.key) {\n        case k.Escape:\n          if (t.popoverState !== 0 || !d.current || p != null && p.activeElement && !d.current.contains(p.activeElement)) return;\n          u.preventDefault(), u.stopPropagation(), a({\n            type: 1\n          }), (m = t.button) == null || m.focus();\n          break;\n      }\n    });\n  q(() => {\n    var u;\n    o.static || t.popoverState === 1 && ((u = o.unmount) == null || u) && a({\n      type: 4,\n      panel: null\n    });\n  }, [t.popoverState, o.unmount, o.static, a]), q(() => {\n    if (!C || t.popoverState !== 0 || !d.current) return;\n    let u = p == null ? void 0 : p.activeElement;\n    d.current.contains(u) || w(d.current, h.First);\n  }, [C, d, t.popoverState]);\n  let x = D(() => ({\n      open: t.popoverState === 0,\n      close: v\n    }), [t, v]),\n    O = {\n      ref: i,\n      id: R,\n      onKeyDown: y,\n      onBlur: C && t.popoverState === 0 ? u => {\n        var E, c, B, e, n;\n        let m = u.relatedTarget;\n        m && d.current && ((E = d.current) != null && E.contains(m) || (a({\n          type: 1\n        }), ((B = (c = t.beforePanelSentinel.current) == null ? void 0 : c.contains) != null && B.call(c, m) || (n = (e = t.afterPanelSentinel.current) == null ? void 0 : e.contains) != null && n.call(e, m)) && m.focus({\n          preventScroll: !0\n        })));\n      } : void 0,\n      tabIndex: -1\n    },\n    L = de(),\n    j = b(() => {\n      let u = d.current;\n      if (!u) return;\n      function m() {\n        _(L.current, {\n          [H.Forwards]: () => {\n            var c;\n            w(u, h.First) === te.Error && ((c = t.afterPanelSentinel.current) == null || c.focus());\n          },\n          [H.Backwards]: () => {\n            var E;\n            (E = t.button) == null || E.focus({\n              preventScroll: !0\n            });\n          }\n        });\n      }\n      m();\n    }),\n    M = b(() => {\n      let u = d.current;\n      if (!u) return;\n      function m() {\n        _(L.current, {\n          [H.Forwards]: () => {\n            var A;\n            if (!t.button) return;\n            let E = ee(),\n              c = E.indexOf(t.button),\n              B = E.slice(0, c + 1),\n              n = [...E.slice(c + 1), ...B];\n            for (let g of n.slice()) if (g.dataset.headlessuiFocusGuard === \"true\" || (A = t.panel) != null && A.contains(g)) {\n              let G = n.indexOf(g);\n              G !== -1 && n.splice(G, 1);\n            }\n            w(n, h.First, {\n              sorted: !1\n            });\n          },\n          [H.Backwards]: () => {\n            var c;\n            w(u, h.Previous) === te.Error && ((c = t.button) == null || c.focus());\n          }\n        });\n      }\n      m();\n    });\n  return I.createElement(Z.Provider, {\n    value: R\n  }, S && f && I.createElement(re, {\n    id: F,\n    ref: t.beforePanelSentinel,\n    features: ne.Focusable,\n    \"data-headlessui-focus-guard\": !0,\n    as: \"button\",\n    type: \"button\",\n    onFocus: j\n  }), J({\n    ourProps: O,\n    theirProps: r,\n    slot: x,\n    defaultTag: we,\n    features: Ne,\n    visible: S,\n    name: \"Popover.Panel\"\n  }), S && f && I.createElement(re, {\n    id: T,\n    ref: t.afterPanelSentinel,\n    features: ne.Focusable,\n    \"data-headlessui-focus-guard\": !0,\n    as: \"button\",\n    type: \"button\",\n    onFocus: M\n  }));\n}\nlet Ke = \"div\";\nfunction We(o, l) {\n  let s = V(null),\n    R = U(s, l),\n    [C, r] = ie([]),\n    t = b(p => {\n      r(P => {\n        let S = P.indexOf(p);\n        if (S !== -1) {\n          let y = P.slice();\n          return y.splice(S, 1), y;\n        }\n        return P;\n      });\n    }),\n    a = b(p => (r(P => [...P, p]), () => t(p))),\n    v = b(() => {\n      var S;\n      let p = Re(s);\n      if (!p) return !1;\n      let P = p.activeElement;\n      return (S = s.current) != null && S.contains(P) ? !0 : C.some(y => {\n        var x, O;\n        return ((x = p.getElementById(y.buttonId.current)) == null ? void 0 : x.contains(P)) || ((O = p.getElementById(y.panelId.current)) == null ? void 0 : O.contains(P));\n      });\n    }),\n    f = b(p => {\n      for (let P of C) P.buttonId.current !== p && P.close();\n    }),\n    F = D(() => ({\n      registerPopover: a,\n      unregisterPopover: t,\n      isFocusWithinPopoverGroup: v,\n      closeOthers: f\n    }), [a, t, v, f]),\n    T = D(() => ({}), []),\n    d = o,\n    i = {\n      ref: R\n    };\n  return I.createElement(se.Provider, {\n    value: F\n  }, J({\n    ourProps: i,\n    theirProps: d,\n    slot: T,\n    defaultTag: Ke,\n    name: \"Popover.Group\"\n  }));\n}\nlet je = $(De),\n  Ve = $(He),\n  $e = $(ke),\n  Je = $(Ue),\n  Xe = $(We),\n  Lt = Object.assign(je, {\n    Button: Ve,\n    Overlay: $e,\n    Panel: Je,\n    Group: Xe\n  });\nexport { Lt as Popover };","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}