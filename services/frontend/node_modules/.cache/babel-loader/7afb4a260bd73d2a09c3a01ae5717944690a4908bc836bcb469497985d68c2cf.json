{"ast":null,"code":"import d, { Fragment as K, createContext as Q, useContext as J, useEffect as P, useMemo as Y, useRef as f, useState as X } from \"react\";\nimport { Features as de, forwardRefWithAs as W, render as Z, RenderStrategy as E } from '../../utils/render.js';\nimport { OpenClosedProvider as fe, State as b, useOpenClosed as $ } from '../../internal/open-closed.js';\nimport { match as D } from '../../utils/match.js';\nimport { useIsMounted as pe } from '../../hooks/use-is-mounted.js';\nimport { useIsoMorphicEffect as me } from '../../hooks/use-iso-morphic-effect.js';\nimport { useLatestValue as V } from '../../hooks/use-latest-value.js';\nimport { useServerHandoffComplete as ee } from '../../hooks/use-server-handoff-complete.js';\nimport { useSyncRefs as te } from '../../hooks/use-sync-refs.js';\nimport { useTransition as ce } from '../../hooks/use-transition.js';\nimport { useEvent as R } from '../../hooks/use-event.js';\nimport { useDisposables as he } from '../../hooks/use-disposables.js';\nimport { classNames as ve } from '../../utils/class-names.js';\nimport { useFlags as ge } from '../../hooks/use-flags.js';\nfunction S() {\n  let n = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"\";\n  return n.split(\" \").filter(t => t.trim().length > 1);\n}\nlet A = Q(null);\nA.displayName = \"TransitionContext\";\nvar Ce = (r => (r.Visible = \"visible\", r.Hidden = \"hidden\", r))(Ce || {});\nfunction Ee() {\n  let n = J(A);\n  if (n === null) throw new Error(\"A <Transition.Child /> is used but it is missing a parent <Transition /> or <Transition.Root />.\");\n  return n;\n}\nfunction be() {\n  let n = J(I);\n  if (n === null) throw new Error(\"A <Transition.Child /> is used but it is missing a parent <Transition /> or <Transition.Root />.\");\n  return n;\n}\nlet I = Q(null);\nI.displayName = \"NestingContext\";\nfunction _(n) {\n  return \"children\" in n ? _(n.children) : n.current.filter(_ref => {\n    let {\n      el: t\n    } = _ref;\n    return t.current !== null;\n  }).filter(_ref2 => {\n    let {\n      state: t\n    } = _ref2;\n    return t === \"visible\";\n  }).length > 0;\n}\nfunction ne(n, t) {\n  let r = V(n),\n    o = f([]),\n    y = pe(),\n    N = he(),\n    p = R(function (s) {\n      let e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : E.Hidden;\n      let a = o.current.findIndex(_ref3 => {\n        let {\n          el: i\n        } = _ref3;\n        return i === s;\n      });\n      a !== -1 && (D(e, {\n        [E.Unmount]() {\n          o.current.splice(a, 1);\n        },\n        [E.Hidden]() {\n          o.current[a].state = \"hidden\";\n        }\n      }), N.microTask(() => {\n        var i;\n        !_(o) && y.current && ((i = r.current) == null || i.call(r));\n      }));\n    }),\n    x = R(s => {\n      let e = o.current.find(_ref4 => {\n        let {\n          el: a\n        } = _ref4;\n        return a === s;\n      });\n      return e ? e.state !== \"visible\" && (e.state = \"visible\") : o.current.push({\n        el: s,\n        state: \"visible\"\n      }), () => p(s, E.Unmount);\n    }),\n    m = f([]),\n    c = f(Promise.resolve()),\n    u = f({\n      enter: [],\n      leave: [],\n      idle: []\n    }),\n    h = R((s, e, a) => {\n      m.current.splice(0), t && (t.chains.current[e] = t.chains.current[e].filter(_ref5 => {\n        let [i] = _ref5;\n        return i !== s;\n      })), t == null || t.chains.current[e].push([s, new Promise(i => {\n        m.current.push(i);\n      })]), t == null || t.chains.current[e].push([s, new Promise(i => {\n        Promise.all(u.current[e].map(_ref6 => {\n          let [l, T] = _ref6;\n          return T;\n        })).then(() => i());\n      })]), e === \"enter\" ? c.current = c.current.then(() => t == null ? void 0 : t.wait.current).then(() => a(e)) : a(e);\n    }),\n    v = R((s, e, a) => {\n      Promise.all(u.current[e].splice(0).map(_ref7 => {\n        let [i, l] = _ref7;\n        return l;\n      })).then(() => {\n        var i;\n        (i = m.current.shift()) == null || i();\n      }).then(() => a(e));\n    });\n  return Y(() => ({\n    children: o,\n    register: x,\n    unregister: p,\n    onStart: h,\n    onStop: v,\n    wait: c,\n    chains: u\n  }), [x, p, o, h, v, u, c]);\n}\nfunction Se() {}\nlet xe = [\"beforeEnter\", \"afterEnter\", \"beforeLeave\", \"afterLeave\"];\nfunction re(n) {\n  var r;\n  let t = {};\n  for (let o of xe) t[o] = (r = n[o]) != null ? r : Se;\n  return t;\n}\nfunction Pe(n) {\n  let t = f(re(n));\n  return P(() => {\n    t.current = re(n);\n  }, [n]), t;\n}\nlet Re = \"div\",\n  ie = de.RenderStrategy;\nfunction ye(n, t) {\n  let {\n      beforeEnter: r,\n      afterEnter: o,\n      beforeLeave: y,\n      afterLeave: N,\n      enter: p,\n      enterFrom: x,\n      enterTo: m,\n      entered: c,\n      leave: u,\n      leaveFrom: h,\n      leaveTo: v,\n      ...s\n    } = n,\n    e = f(null),\n    a = te(e, t),\n    i = s.unmount ? E.Unmount : E.Hidden,\n    {\n      show: l,\n      appear: T,\n      initial: se\n    } = Ee(),\n    [g, M] = X(l ? \"visible\" : \"hidden\"),\n    z = be(),\n    {\n      register: F,\n      unregister: L\n    } = z,\n    U = f(null);\n  P(() => F(e), [F, e]), P(() => {\n    if (i === E.Hidden && e.current) {\n      if (l && g !== \"visible\") {\n        M(\"visible\");\n        return;\n      }\n      return D(g, {\n        [\"hidden\"]: () => L(e),\n        [\"visible\"]: () => F(e)\n      });\n    }\n  }, [g, e, F, L, l, i]);\n  let j = V({\n      enter: S(p),\n      enterFrom: S(x),\n      enterTo: S(m),\n      entered: S(c),\n      leave: S(u),\n      leaveFrom: S(h),\n      leaveTo: S(v)\n    }),\n    w = Pe({\n      beforeEnter: r,\n      afterEnter: o,\n      beforeLeave: y,\n      afterLeave: N\n    }),\n    k = ee();\n  P(() => {\n    if (k && g === \"visible\" && e.current === null) throw new Error(\"Did you forget to passthrough the `ref` to the actual DOM node?\");\n  }, [e, g, k]);\n  let G = se && !T,\n    ae = (() => !k || G || U.current === l ? \"idle\" : l ? \"enter\" : \"leave\")(),\n    H = ge(0),\n    le = R(C => D(C, {\n      enter: () => {\n        H.addFlag(b.Opening), w.current.beforeEnter();\n      },\n      leave: () => {\n        H.addFlag(b.Closing), w.current.beforeLeave();\n      },\n      idle: () => {}\n    })),\n    ue = R(C => D(C, {\n      enter: () => {\n        H.removeFlag(b.Opening), w.current.afterEnter();\n      },\n      leave: () => {\n        H.removeFlag(b.Closing), w.current.afterLeave();\n      },\n      idle: () => {}\n    })),\n    O = ne(() => {\n      M(\"hidden\"), L(e);\n    }, z);\n  ce({\n    container: e,\n    classes: j,\n    direction: ae,\n    onStart: V(C => {\n      O.onStart(e, C, le);\n    }),\n    onStop: V(C => {\n      O.onStop(e, C, ue), C === \"leave\" && !_(O) && (M(\"hidden\"), L(e));\n    })\n  }), P(() => {\n    G && (i === E.Hidden ? U.current = null : U.current = l);\n  }, [l, G, g]);\n  let B = s,\n    Te = {\n      ref: a\n    };\n  return T && l && (B = {\n    ...B,\n    className: ve(s.className, ...j.current.enter, ...j.current.enterFrom)\n  }), d.createElement(I.Provider, {\n    value: O\n  }, d.createElement(fe, {\n    value: D(g, {\n      [\"visible\"]: b.Open,\n      [\"hidden\"]: b.Closed\n    }) | H.flags\n  }, Z({\n    ourProps: Te,\n    theirProps: B,\n    defaultTag: Re,\n    features: ie,\n    visible: g === \"visible\",\n    name: \"Transition.Child\"\n  })));\n}\nfunction Ne(n, t) {\n  let {\n      show: r,\n      appear: o = !1,\n      unmount: y,\n      ...N\n    } = n,\n    p = f(null),\n    x = te(p, t);\n  ee();\n  let m = $();\n  if (r === void 0 && m !== null && (r = (m & b.Open) === b.Open), ![!0, !1].includes(r)) throw new Error(\"A <Transition /> is used but it is missing a `show={true | false}` prop.\");\n  let [c, u] = X(r ? \"visible\" : \"hidden\"),\n    h = ne(() => {\n      u(\"hidden\");\n    }),\n    [v, s] = X(!0),\n    e = f([r]);\n  me(() => {\n    v !== !1 && e.current[e.current.length - 1] !== r && (e.current.push(r), s(!1));\n  }, [e, r]);\n  let a = Y(() => ({\n    show: r,\n    appear: o,\n    initial: v\n  }), [r, o, v]);\n  P(() => {\n    if (r) u(\"visible\");else if (!_(h)) u(\"hidden\");else {\n      let l = p.current;\n      if (!l) return;\n      let T = l.getBoundingClientRect();\n      T.x === 0 && T.y === 0 && T.width === 0 && T.height === 0 && u(\"hidden\");\n    }\n  }, [r, h]);\n  let i = {\n    unmount: y\n  };\n  return d.createElement(I.Provider, {\n    value: h\n  }, d.createElement(A.Provider, {\n    value: a\n  }, Z({\n    ourProps: {\n      ...i,\n      as: K,\n      children: d.createElement(oe, {\n        ref: x,\n        ...i,\n        ...N\n      })\n    },\n    theirProps: {},\n    defaultTag: K,\n    features: ie,\n    visible: c === \"visible\",\n    name: \"Transition\"\n  })));\n}\nfunction He(n, t) {\n  let r = J(A) !== null,\n    o = $() !== null;\n  return d.createElement(d.Fragment, null, !r && o ? d.createElement(q, {\n    ref: t,\n    ...n\n  }) : d.createElement(oe, {\n    ref: t,\n    ...n\n  }));\n}\nlet q = W(Ne),\n  oe = W(ye),\n  De = W(He),\n  tt = Object.assign(q, {\n    Child: De,\n    Root: q\n  });\nexport { tt as Transition };","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}