{"ast":null,"code":"import L, { useEffect as U, useRef as d } from \"react\";\nimport { forwardRefWithAs as N, render as I } from '../../utils/render.js';\nimport { useServerHandoffComplete as x } from '../../hooks/use-server-handoff-complete.js';\nimport { useSyncRefs as w } from '../../hooks/use-sync-refs.js';\nimport { Features as g, Hidden as k } from '../../internal/hidden.js';\nimport { focusElement as f, focusIn as M, Focus as p, FocusResult as G } from '../../utils/focus-management.js';\nimport { match as A } from '../../utils/match.js';\nimport { useEvent as C } from '../../hooks/use-event.js';\nimport { useTabDirection as K, Direction as b } from '../../hooks/use-tab-direction.js';\nimport { useIsMounted as O } from '../../hooks/use-is-mounted.js';\nimport { useOwnerDocument as W } from '../../hooks/use-owner.js';\nimport { useEventListener as V } from '../../hooks/use-event-listener.js';\nimport { microTask as F } from '../../utils/micro-task.js';\nimport { useWatch as y } from '../../hooks/use-watch.js';\nimport { useDisposables as q } from '../../hooks/use-disposables.js';\nimport { onDocumentReady as D } from '../../utils/document-ready.js';\nfunction P(t) {\n  if (!t) return new Set();\n  if (typeof t == \"function\") return new Set(t());\n  let n = new Set();\n  for (let e of t.current) e.current instanceof HTMLElement && n.add(e.current);\n  return n;\n}\nlet J = \"div\";\nvar h = (r => (r[r.None = 1] = \"None\", r[r.InitialFocus = 2] = \"InitialFocus\", r[r.TabLock = 4] = \"TabLock\", r[r.FocusLock = 8] = \"FocusLock\", r[r.RestoreFocus = 16] = \"RestoreFocus\", r[r.All = 30] = \"All\", r))(h || {});\nfunction X(t, n) {\n  let e = d(null),\n    o = w(e, n),\n    {\n      initialFocus: u,\n      containers: i,\n      features: r = 30,\n      ...l\n    } = t;\n  x() || (r = 1);\n  let m = W(e);\n  Y({\n    ownerDocument: m\n  }, Boolean(r & 16));\n  let c = Z({\n    ownerDocument: m,\n    container: e,\n    initialFocus: u\n  }, Boolean(r & 2));\n  $({\n    ownerDocument: m,\n    container: e,\n    containers: i,\n    previousActiveElement: c\n  }, Boolean(r & 8));\n  let v = K(),\n    R = C(s => {\n      let T = e.current;\n      if (!T) return;\n      (B => B())(() => {\n        A(v.current, {\n          [b.Forwards]: () => {\n            M(T, p.First, {\n              skipElements: [s.relatedTarget]\n            });\n          },\n          [b.Backwards]: () => {\n            M(T, p.Last, {\n              skipElements: [s.relatedTarget]\n            });\n          }\n        });\n      });\n    }),\n    _ = q(),\n    H = d(!1),\n    j = {\n      ref: o,\n      onKeyDown(s) {\n        s.key == \"Tab\" && (H.current = !0, _.requestAnimationFrame(() => {\n          H.current = !1;\n        }));\n      },\n      onBlur(s) {\n        let T = P(i);\n        e.current instanceof HTMLElement && T.add(e.current);\n        let E = s.relatedTarget;\n        E instanceof HTMLElement && E.dataset.headlessuiFocusGuard !== \"true\" && (S(T, E) || (H.current ? M(e.current, A(v.current, {\n          [b.Forwards]: () => p.Next,\n          [b.Backwards]: () => p.Previous\n        }) | p.WrapAround, {\n          relativeTo: s.target\n        }) : s.target instanceof HTMLElement && f(s.target)));\n      }\n    };\n  return L.createElement(L.Fragment, null, Boolean(r & 4) && L.createElement(k, {\n    as: \"button\",\n    type: \"button\",\n    \"data-headlessui-focus-guard\": !0,\n    onFocus: R,\n    features: g.Focusable\n  }), I({\n    ourProps: j,\n    theirProps: l,\n    defaultTag: J,\n    name: \"FocusTrap\"\n  }), Boolean(r & 4) && L.createElement(k, {\n    as: \"button\",\n    type: \"button\",\n    \"data-headlessui-focus-guard\": !0,\n    onFocus: R,\n    features: g.Focusable\n  }));\n}\nlet z = N(X),\n  Re = Object.assign(z, {\n    features: h\n  }),\n  a = [];\nD(() => {\n  function t(n) {\n    n.target instanceof HTMLElement && n.target !== document.body && a[0] !== n.target && (a.unshift(n.target), a = a.filter(e => e != null && e.isConnected), a.splice(10));\n  }\n  window.addEventListener(\"click\", t, {\n    capture: !0\n  }), window.addEventListener(\"mousedown\", t, {\n    capture: !0\n  }), window.addEventListener(\"focus\", t, {\n    capture: !0\n  }), document.body.addEventListener(\"click\", t, {\n    capture: !0\n  }), document.body.addEventListener(\"mousedown\", t, {\n    capture: !0\n  }), document.body.addEventListener(\"focus\", t, {\n    capture: !0\n  });\n});\nfunction Q() {\n  let t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : !0;\n  let n = d(a.slice());\n  return y((_ref, _ref2) => {\n    let [e] = _ref;\n    let [o] = _ref2;\n    o === !0 && e === !1 && F(() => {\n      n.current.splice(0);\n    }), o === !1 && e === !0 && (n.current = a.slice());\n  }, [t, a, n]), C(() => {\n    var e;\n    return (e = n.current.find(o => o != null && o.isConnected)) != null ? e : null;\n  });\n}\nfunction Y(_ref3, n) {\n  let {\n    ownerDocument: t\n  } = _ref3;\n  let e = Q(n);\n  y(() => {\n    n || (t == null ? void 0 : t.activeElement) === (t == null ? void 0 : t.body) && f(e());\n  }, [n]);\n  let o = d(!1);\n  U(() => (o.current = !1, () => {\n    o.current = !0, F(() => {\n      o.current && f(e());\n    });\n  }), []);\n}\nfunction Z(_ref4, o) {\n  let {\n    ownerDocument: t,\n    container: n,\n    initialFocus: e\n  } = _ref4;\n  let u = d(null),\n    i = O();\n  return y(() => {\n    if (!o) return;\n    let r = n.current;\n    r && F(() => {\n      if (!i.current) return;\n      let l = t == null ? void 0 : t.activeElement;\n      if (e != null && e.current) {\n        if ((e == null ? void 0 : e.current) === l) {\n          u.current = l;\n          return;\n        }\n      } else if (r.contains(l)) {\n        u.current = l;\n        return;\n      }\n      e != null && e.current ? f(e.current) : M(r, p.First) === G.Error && console.warn(\"There are no focusable elements inside the <FocusTrap />\"), u.current = t == null ? void 0 : t.activeElement;\n    });\n  }, [o]), u;\n}\nfunction $(_ref5, u) {\n  let {\n    ownerDocument: t,\n    container: n,\n    containers: e,\n    previousActiveElement: o\n  } = _ref5;\n  let i = O();\n  V(t == null ? void 0 : t.defaultView, \"focus\", r => {\n    if (!u || !i.current) return;\n    let l = P(e);\n    n.current instanceof HTMLElement && l.add(n.current);\n    let m = o.current;\n    if (!m) return;\n    let c = r.target;\n    c && c instanceof HTMLElement ? S(l, c) ? (o.current = c, f(c)) : (r.preventDefault(), r.stopPropagation(), f(m)) : f(o.current);\n  }, !0);\n}\nfunction S(t, n) {\n  for (let e of t) if (e.contains(n)) return !0;\n  return !1;\n}\nexport { Re as FocusTrap };","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}