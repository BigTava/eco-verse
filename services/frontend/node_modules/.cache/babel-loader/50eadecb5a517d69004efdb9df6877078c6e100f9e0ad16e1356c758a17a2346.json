{"ast":null,"code":"import z, { Fragment as xe, createContext as ue, createRef as Ce, useCallback as Oe, useContext as pe, useEffect as se, useMemo as D, useReducer as ge, useRef as A } from \"react\";\nimport { useComputed as te } from '../../hooks/use-computed.js';\nimport { useDisposables as ne } from '../../hooks/use-disposables.js';\nimport { useEvent as C } from '../../hooks/use-event.js';\nimport { useId as K } from '../../hooks/use-id.js';\nimport { useIsoMorphicEffect as _ } from '../../hooks/use-iso-morphic-effect.js';\nimport { useLatestValue as ye } from '../../hooks/use-latest-value.js';\nimport { useOutsideClick as Re } from '../../hooks/use-outside-click.js';\nimport { useResolveButtonType as ve } from '../../hooks/use-resolve-button-type.js';\nimport { useSyncRefs as W } from '../../hooks/use-sync-refs.js';\nimport { useTreeWalker as Pe } from '../../hooks/use-tree-walker.js';\nimport { calculateActiveIndex as Ae, Focus as y } from '../../utils/calculate-active-index.js';\nimport { disposables as be } from '../../utils/disposables.js';\nimport { forwardRefWithAs as w, render as U, compact as Ee, Features as de } from '../../utils/render.js';\nimport { isDisabledReactIssue7711 as Se } from '../../utils/bugs.js';\nimport { match as N } from '../../utils/match.js';\nimport { objectToFormEntries as Ie } from '../../utils/form.js';\nimport { sortByDomNode as Le } from '../../utils/focus-management.js';\nimport { Hidden as Ve, Features as De } from '../../internal/hidden.js';\nimport { useOpenClosed as Fe, State as ee, OpenClosedProvider as Me } from '../../internal/open-closed.js';\nimport { Keys as v } from '../keyboard.js';\nimport { useControllable as _e } from '../../hooks/use-controllable.js';\nimport { useWatch as fe } from '../../hooks/use-watch.js';\nimport { useTrackedPointer as he } from '../../hooks/use-tracked-pointer.js';\nimport { isMobile as Be } from '../../utils/platform.js';\nvar ke = (e => (e[e.Open = 0] = \"Open\", e[e.Closed = 1] = \"Closed\", e))(ke || {}),\n  we = (e => (e[e.Single = 0] = \"Single\", e[e.Multi = 1] = \"Multi\", e))(we || {}),\n  Ue = (e => (e[e.Pointer = 0] = \"Pointer\", e[e.Other = 1] = \"Other\", e))(Ue || {}),\n  Ne = (n => (n[n.OpenCombobox = 0] = \"OpenCombobox\", n[n.CloseCombobox = 1] = \"CloseCombobox\", n[n.GoToOption = 2] = \"GoToOption\", n[n.RegisterOption = 3] = \"RegisterOption\", n[n.UnregisterOption = 4] = \"UnregisterOption\", n[n.RegisterLabel = 5] = \"RegisterLabel\", n))(Ne || {});\nfunction re(t) {\n  let l = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : e => e;\n  let e = t.activeOptionIndex !== null ? t.options[t.activeOptionIndex] : null,\n    r = Le(l(t.options.slice()), b => b.dataRef.current.domRef.current),\n    i = e ? r.indexOf(e) : null;\n  return i === -1 && (i = null), {\n    options: r,\n    activeOptionIndex: i\n  };\n}\nlet He = {\n    [1](t) {\n      var l;\n      return (l = t.dataRef.current) != null && l.disabled || t.comboboxState === 1 ? t : {\n        ...t,\n        activeOptionIndex: null,\n        comboboxState: 1\n      };\n    },\n    [0](t) {\n      var e;\n      if ((e = t.dataRef.current) != null && e.disabled || t.comboboxState === 0) return t;\n      let l = t.activeOptionIndex;\n      if (t.dataRef.current) {\n        let {\n            isSelected: r\n          } = t.dataRef.current,\n          i = t.options.findIndex(b => r(b.dataRef.current.value));\n        i !== -1 && (l = i);\n      }\n      return {\n        ...t,\n        comboboxState: 0,\n        activeOptionIndex: l\n      };\n    },\n    [2](t, l) {\n      var i, b, n, d;\n      if ((i = t.dataRef.current) != null && i.disabled || (b = t.dataRef.current) != null && b.optionsRef.current && !((n = t.dataRef.current) != null && n.optionsPropsRef.current.static) && t.comboboxState === 1) return t;\n      let e = re(t);\n      if (e.activeOptionIndex === null) {\n        let o = e.options.findIndex(u => !u.dataRef.current.disabled);\n        o !== -1 && (e.activeOptionIndex = o);\n      }\n      let r = Ae(l, {\n        resolveItems: () => e.options,\n        resolveActiveIndex: () => e.activeOptionIndex,\n        resolveId: o => o.id,\n        resolveDisabled: o => o.dataRef.current.disabled\n      });\n      return {\n        ...t,\n        ...e,\n        activeOptionIndex: r,\n        activationTrigger: (d = l.trigger) != null ? d : 1\n      };\n    },\n    [3]: (t, l) => {\n      var b, n;\n      let e = {\n          id: l.id,\n          dataRef: l.dataRef\n        },\n        r = re(t, d => [...d, e]);\n      t.activeOptionIndex === null && (b = t.dataRef.current) != null && b.isSelected(l.dataRef.current.value) && (r.activeOptionIndex = r.options.indexOf(e));\n      let i = {\n        ...t,\n        ...r,\n        activationTrigger: 1\n      };\n      return (n = t.dataRef.current) != null && n.__demoMode && t.dataRef.current.value === void 0 && (i.activeOptionIndex = 0), i;\n    },\n    [4]: (t, l) => {\n      let e = re(t, r => {\n        let i = r.findIndex(b => b.id === l.id);\n        return i !== -1 && r.splice(i, 1), r;\n      });\n      return {\n        ...t,\n        ...e,\n        activationTrigger: 1\n      };\n    },\n    [5]: (t, l) => ({\n      ...t,\n      labelId: l.id\n    })\n  },\n  ae = ue(null);\nae.displayName = \"ComboboxActionsContext\";\nfunction $(t) {\n  let l = pe(ae);\n  if (l === null) {\n    let e = new Error(`<${t} /> is missing a parent <Combobox /> component.`);\n    throw Error.captureStackTrace && Error.captureStackTrace(e, $), e;\n  }\n  return l;\n}\nlet le = ue(null);\nle.displayName = \"ComboboxDataContext\";\nfunction H(t) {\n  let l = pe(le);\n  if (l === null) {\n    let e = new Error(`<${t} /> is missing a parent <Combobox /> component.`);\n    throw Error.captureStackTrace && Error.captureStackTrace(e, H), e;\n  }\n  return l;\n}\nfunction Ge(t, l) {\n  return N(l.type, He, t, l);\n}\nlet Xe = xe;\nfunction je(t, l) {\n  let {\n      value: e,\n      defaultValue: r,\n      onChange: i,\n      form: b,\n      name: n,\n      by: d = (p, T) => p === T,\n      disabled: o = !1,\n      __demoMode: u = !1,\n      nullable: P = !1,\n      multiple: f = !1,\n      ...E\n    } = t,\n    [c = f ? [] : void 0, g] = _e(e, i, r),\n    [m, x] = ge(Ge, {\n      dataRef: Ce(),\n      comboboxState: u ? 0 : 1,\n      options: [],\n      activeOptionIndex: null,\n      activationTrigger: 1,\n      labelId: null\n    }),\n    L = A(!1),\n    F = A({\n      static: !1,\n      hold: !1\n    }),\n    h = A(null),\n    B = A(null),\n    k = A(null),\n    G = A(null),\n    V = C(typeof d == \"string\" ? (p, T) => {\n      let R = d;\n      return (p == null ? void 0 : p[R]) === (T == null ? void 0 : T[R]);\n    } : d),\n    M = Oe(p => N(s.mode, {\n      [1]: () => c.some(T => V(T, p)),\n      [0]: () => V(c, p)\n    }), [c]),\n    s = D(() => ({\n      ...m,\n      optionsPropsRef: F,\n      labelRef: h,\n      inputRef: B,\n      buttonRef: k,\n      optionsRef: G,\n      value: c,\n      defaultValue: r,\n      disabled: o,\n      mode: f ? 1 : 0,\n      get activeOptionIndex() {\n        if (L.current && m.activeOptionIndex === null && m.options.length > 0) {\n          let p = m.options.findIndex(T => !T.dataRef.current.disabled);\n          if (p !== -1) return p;\n        }\n        return m.activeOptionIndex;\n      },\n      compare: V,\n      isSelected: M,\n      nullable: P,\n      __demoMode: u\n    }), [c, r, o, f, P, u, m]),\n    O = A(s.activeOptionIndex !== null ? s.options[s.activeOptionIndex] : null);\n  se(() => {\n    let p = s.activeOptionIndex !== null ? s.options[s.activeOptionIndex] : null;\n    O.current !== p && (O.current = p);\n  }), _(() => {\n    m.dataRef.current = s;\n  }, [s]), Re([s.buttonRef, s.inputRef, s.optionsRef], () => oe.closeCombobox(), s.comboboxState === 0);\n  let a = D(() => ({\n      open: s.comboboxState === 0,\n      disabled: o,\n      activeIndex: s.activeOptionIndex,\n      activeOption: s.activeOptionIndex === null ? null : s.options[s.activeOptionIndex].dataRef.current.value,\n      value: c\n    }), [s, o, c]),\n    I = C(p => {\n      let T = s.options.find(R => R.id === p);\n      T && j(T.dataRef.current.value);\n    }),\n    S = C(() => {\n      if (s.activeOptionIndex !== null) {\n        let {\n          dataRef: p,\n          id: T\n        } = s.options[s.activeOptionIndex];\n        j(p.current.value), oe.goToOption(y.Specific, T);\n      }\n    }),\n    X = C(() => {\n      x({\n        type: 0\n      }), L.current = !0;\n    }),\n    q = C(() => {\n      x({\n        type: 1\n      }), L.current = !1;\n    }),\n    Q = C((p, T, R) => (L.current = !1, p === y.Specific ? x({\n      type: 2,\n      focus: y.Specific,\n      id: T,\n      trigger: R\n    }) : x({\n      type: 2,\n      focus: p,\n      trigger: R\n    }))),\n    Y = C((p, T) => (x({\n      type: 3,\n      id: p,\n      dataRef: T\n    }), () => {\n      var R;\n      ((R = O.current) == null ? void 0 : R.id) === p && (L.current = !0), x({\n        type: 4,\n        id: p\n      });\n    })),\n    ce = C(p => (x({\n      type: 5,\n      id: p\n    }), () => x({\n      type: 5,\n      id: null\n    }))),\n    j = C(p => N(s.mode, {\n      [0]() {\n        return g == null ? void 0 : g(p);\n      },\n      [1]() {\n        let T = s.value.slice(),\n          R = T.findIndex(J => V(J, p));\n        return R === -1 ? T.push(p) : T.splice(R, 1), g == null ? void 0 : g(T);\n      }\n    })),\n    oe = D(() => ({\n      onChange: j,\n      registerOption: Y,\n      registerLabel: ce,\n      goToOption: Q,\n      closeCombobox: q,\n      openCombobox: X,\n      selectActiveOption: S,\n      selectOption: I\n    }), []),\n    Te = l === null ? {} : {\n      ref: l\n    },\n    Z = A(null),\n    me = ne();\n  return se(() => {\n    Z.current && r !== void 0 && me.addEventListener(Z.current, \"reset\", () => {\n      j(r);\n    });\n  }, [Z, j]), z.createElement(ae.Provider, {\n    value: oe\n  }, z.createElement(le.Provider, {\n    value: s\n  }, z.createElement(Me, {\n    value: N(s.comboboxState, {\n      [0]: ee.Open,\n      [1]: ee.Closed\n    })\n  }, n != null && c != null && Ie({\n    [n]: c\n  }).map((_ref, R) => {\n    let [p, T] = _ref;\n    return z.createElement(Ve, {\n      features: De.Hidden,\n      ref: R === 0 ? J => {\n        var ie;\n        Z.current = (ie = J == null ? void 0 : J.closest(\"form\")) != null ? ie : null;\n      } : void 0,\n      ...Ee({\n        key: p,\n        as: \"input\",\n        type: \"hidden\",\n        hidden: !0,\n        readOnly: !0,\n        form: b,\n        name: p,\n        value: T\n      })\n    });\n  }), U({\n    ourProps: Te,\n    theirProps: E,\n    slot: a,\n    defaultTag: Xe,\n    name: \"Combobox\"\n  }))));\n}\nlet Je = \"input\";\nfunction Ke(t, l) {\n  var V, M, s, O;\n  let e = K(),\n    {\n      id: r = `headlessui-combobox-input-${e}`,\n      onChange: i,\n      displayValue: b,\n      type: n = \"text\",\n      ...d\n    } = t,\n    o = H(\"Combobox.Input\"),\n    u = $(\"Combobox.Input\"),\n    P = W(o.inputRef, l),\n    f = A(!1),\n    E = ne(),\n    c = function () {\n      var a;\n      return typeof b == \"function\" && o.value !== void 0 ? (a = b(o.value)) != null ? a : \"\" : typeof o.value == \"string\" ? o.value : \"\";\n    }();\n  fe((_ref2, _ref3) => {\n    let [a, I] = _ref2;\n    let [S, X] = _ref3;\n    f.current || o.inputRef.current && (X === 0 && I === 1 || a !== S) && (o.inputRef.current.value = a);\n  }, [c, o.comboboxState]), fe((_ref4, _ref5) => {\n    let [a] = _ref4;\n    let [I] = _ref5;\n    if (a === 0 && I === 1) {\n      let S = o.inputRef.current;\n      if (!S) return;\n      let X = S.value,\n        {\n          selectionStart: q,\n          selectionEnd: Q,\n          selectionDirection: Y\n        } = S;\n      S.value = \"\", S.value = X, Y !== null ? S.setSelectionRange(q, Q, Y) : S.setSelectionRange(q, Q);\n    }\n  }, [o.comboboxState]);\n  let g = A(!1),\n    m = C(() => {\n      g.current = !0;\n    }),\n    x = C(() => {\n      setTimeout(() => {\n        g.current = !1;\n      });\n    }),\n    L = C(a => {\n      switch (f.current = !0, a.key) {\n        case v.Backspace:\n        case v.Delete:\n          if (o.mode !== 0 || !o.nullable) return;\n          let I = a.currentTarget;\n          E.requestAnimationFrame(() => {\n            I.value === \"\" && (u.onChange(null), o.optionsRef.current && (o.optionsRef.current.scrollTop = 0), u.goToOption(y.Nothing));\n          });\n          break;\n        case v.Enter:\n          if (f.current = !1, o.comboboxState !== 0 || g.current) return;\n          if (a.preventDefault(), a.stopPropagation(), o.activeOptionIndex === null) {\n            u.closeCombobox();\n            return;\n          }\n          u.selectActiveOption(), o.mode === 0 && u.closeCombobox();\n          break;\n        case v.ArrowDown:\n          return f.current = !1, a.preventDefault(), a.stopPropagation(), N(o.comboboxState, {\n            [0]: () => {\n              u.goToOption(y.Next);\n            },\n            [1]: () => {\n              u.openCombobox();\n            }\n          });\n        case v.ArrowUp:\n          return f.current = !1, a.preventDefault(), a.stopPropagation(), N(o.comboboxState, {\n            [0]: () => {\n              u.goToOption(y.Previous);\n            },\n            [1]: () => {\n              u.openCombobox(), E.nextFrame(() => {\n                o.value || u.goToOption(y.Last);\n              });\n            }\n          });\n        case v.Home:\n          if (a.shiftKey) break;\n          return f.current = !1, a.preventDefault(), a.stopPropagation(), u.goToOption(y.First);\n        case v.PageUp:\n          return f.current = !1, a.preventDefault(), a.stopPropagation(), u.goToOption(y.First);\n        case v.End:\n          if (a.shiftKey) break;\n          return f.current = !1, a.preventDefault(), a.stopPropagation(), u.goToOption(y.Last);\n        case v.PageDown:\n          return f.current = !1, a.preventDefault(), a.stopPropagation(), u.goToOption(y.Last);\n        case v.Escape:\n          return f.current = !1, o.comboboxState !== 0 ? void 0 : (a.preventDefault(), o.optionsRef.current && !o.optionsPropsRef.current.static && a.stopPropagation(), u.closeCombobox());\n        case v.Tab:\n          if (f.current = !1, o.comboboxState !== 0) return;\n          o.mode === 0 && u.selectActiveOption(), u.closeCombobox();\n          break;\n      }\n    }),\n    F = C(a => {\n      u.openCombobox(), i == null || i(a);\n    }),\n    h = C(() => {\n      f.current = !1;\n    }),\n    B = te(() => {\n      if (o.labelId) return [o.labelId].join(\" \");\n    }, [o.labelId]),\n    k = D(() => ({\n      open: o.comboboxState === 0,\n      disabled: o.disabled\n    }), [o]),\n    G = {\n      ref: P,\n      id: r,\n      role: \"combobox\",\n      type: n,\n      \"aria-controls\": (V = o.optionsRef.current) == null ? void 0 : V.id,\n      \"aria-expanded\": o.disabled ? void 0 : o.comboboxState === 0,\n      \"aria-activedescendant\": o.activeOptionIndex === null || (M = o.options[o.activeOptionIndex]) == null ? void 0 : M.id,\n      \"aria-labelledby\": B,\n      \"aria-autocomplete\": \"list\",\n      defaultValue: (O = (s = t.defaultValue) != null ? s : o.defaultValue !== void 0 ? b == null ? void 0 : b(o.defaultValue) : null) != null ? O : o.defaultValue,\n      disabled: o.disabled,\n      onCompositionStart: m,\n      onCompositionEnd: x,\n      onKeyDown: L,\n      onChange: F,\n      onBlur: h\n    };\n  return U({\n    ourProps: G,\n    theirProps: d,\n    slot: k,\n    defaultTag: Je,\n    name: \"Combobox.Input\"\n  });\n}\nlet We = \"button\";\nfunction $e(t, l) {\n  var g;\n  let e = H(\"Combobox.Button\"),\n    r = $(\"Combobox.Button\"),\n    i = W(e.buttonRef, l),\n    b = K(),\n    {\n      id: n = `headlessui-combobox-button-${b}`,\n      ...d\n    } = t,\n    o = ne(),\n    u = C(m => {\n      switch (m.key) {\n        case v.ArrowDown:\n          return m.preventDefault(), m.stopPropagation(), e.comboboxState === 1 && r.openCombobox(), o.nextFrame(() => {\n            var x;\n            return (x = e.inputRef.current) == null ? void 0 : x.focus({\n              preventScroll: !0\n            });\n          });\n        case v.ArrowUp:\n          return m.preventDefault(), m.stopPropagation(), e.comboboxState === 1 && (r.openCombobox(), o.nextFrame(() => {\n            e.value || r.goToOption(y.Last);\n          })), o.nextFrame(() => {\n            var x;\n            return (x = e.inputRef.current) == null ? void 0 : x.focus({\n              preventScroll: !0\n            });\n          });\n        case v.Escape:\n          return e.comboboxState !== 0 ? void 0 : (m.preventDefault(), e.optionsRef.current && !e.optionsPropsRef.current.static && m.stopPropagation(), r.closeCombobox(), o.nextFrame(() => {\n            var x;\n            return (x = e.inputRef.current) == null ? void 0 : x.focus({\n              preventScroll: !0\n            });\n          }));\n        default:\n          return;\n      }\n    }),\n    P = C(m => {\n      if (Se(m.currentTarget)) return m.preventDefault();\n      e.comboboxState === 0 ? r.closeCombobox() : (m.preventDefault(), r.openCombobox()), o.nextFrame(() => {\n        var x;\n        return (x = e.inputRef.current) == null ? void 0 : x.focus({\n          preventScroll: !0\n        });\n      });\n    }),\n    f = te(() => {\n      if (e.labelId) return [e.labelId, n].join(\" \");\n    }, [e.labelId, n]),\n    E = D(() => ({\n      open: e.comboboxState === 0,\n      disabled: e.disabled,\n      value: e.value\n    }), [e]),\n    c = {\n      ref: i,\n      id: n,\n      type: ve(t, e.buttonRef),\n      tabIndex: -1,\n      \"aria-haspopup\": \"listbox\",\n      \"aria-controls\": (g = e.optionsRef.current) == null ? void 0 : g.id,\n      \"aria-expanded\": e.disabled ? void 0 : e.comboboxState === 0,\n      \"aria-labelledby\": f,\n      disabled: e.disabled,\n      onClick: P,\n      onKeyDown: u\n    };\n  return U({\n    ourProps: c,\n    theirProps: d,\n    slot: E,\n    defaultTag: We,\n    name: \"Combobox.Button\"\n  });\n}\nlet qe = \"label\";\nfunction Qe(t, l) {\n  let e = K(),\n    {\n      id: r = `headlessui-combobox-label-${e}`,\n      ...i\n    } = t,\n    b = H(\"Combobox.Label\"),\n    n = $(\"Combobox.Label\"),\n    d = W(b.labelRef, l);\n  _(() => n.registerLabel(r), [r]);\n  let o = C(() => {\n      var f;\n      return (f = b.inputRef.current) == null ? void 0 : f.focus({\n        preventScroll: !0\n      });\n    }),\n    u = D(() => ({\n      open: b.comboboxState === 0,\n      disabled: b.disabled\n    }), [b]);\n  return U({\n    ourProps: {\n      ref: d,\n      id: r,\n      onClick: o\n    },\n    theirProps: i,\n    slot: u,\n    defaultTag: qe,\n    name: \"Combobox.Label\"\n  });\n}\nlet Ye = \"ul\",\n  Ze = de.RenderStrategy | de.Static;\nfunction ze(t, l) {\n  let e = K(),\n    {\n      id: r = `headlessui-combobox-options-${e}`,\n      hold: i = !1,\n      ...b\n    } = t,\n    n = H(\"Combobox.Options\"),\n    d = W(n.optionsRef, l),\n    o = Fe(),\n    u = (() => o !== null ? (o & ee.Open) === ee.Open : n.comboboxState === 0)();\n  _(() => {\n    var c;\n    n.optionsPropsRef.current.static = (c = t.static) != null ? c : !1;\n  }, [n.optionsPropsRef, t.static]), _(() => {\n    n.optionsPropsRef.current.hold = i;\n  }, [n.optionsPropsRef, i]), Pe({\n    container: n.optionsRef.current,\n    enabled: n.comboboxState === 0,\n    accept(c) {\n      return c.getAttribute(\"role\") === \"option\" ? NodeFilter.FILTER_REJECT : c.hasAttribute(\"role\") ? NodeFilter.FILTER_SKIP : NodeFilter.FILTER_ACCEPT;\n    },\n    walk(c) {\n      c.setAttribute(\"role\", \"none\");\n    }\n  });\n  let P = te(() => {\n      var c, g;\n      return (g = n.labelId) != null ? g : (c = n.buttonRef.current) == null ? void 0 : c.id;\n    }, [n.labelId, n.buttonRef.current]),\n    f = D(() => ({\n      open: n.comboboxState === 0\n    }), [n]),\n    E = {\n      \"aria-labelledby\": P,\n      role: \"listbox\",\n      \"aria-multiselectable\": n.mode === 1 ? !0 : void 0,\n      id: r,\n      ref: d\n    };\n  return U({\n    ourProps: E,\n    theirProps: b,\n    slot: f,\n    defaultTag: Ye,\n    features: Ze,\n    visible: u,\n    name: \"Combobox.Options\"\n  });\n}\nlet eo = \"li\";\nfunction oo(t, l) {\n  var M, s;\n  let e = K(),\n    {\n      id: r = `headlessui-combobox-option-${e}`,\n      disabled: i = !1,\n      value: b,\n      ...n\n    } = t,\n    d = H(\"Combobox.Option\"),\n    o = $(\"Combobox.Option\"),\n    u = d.activeOptionIndex !== null ? d.options[d.activeOptionIndex].id === r : !1,\n    P = d.isSelected(b),\n    f = A(null),\n    E = ye({\n      disabled: i,\n      value: b,\n      domRef: f,\n      textValue: (s = (M = f.current) == null ? void 0 : M.textContent) == null ? void 0 : s.toLowerCase()\n    }),\n    c = W(l, f),\n    g = C(() => o.selectOption(r));\n  _(() => o.registerOption(r, E), [E, r]);\n  let m = A(!d.__demoMode);\n  _(() => {\n    if (!d.__demoMode) return;\n    let O = be();\n    return O.requestAnimationFrame(() => {\n      m.current = !0;\n    }), O.dispose;\n  }, []), _(() => {\n    if (d.comboboxState !== 0 || !u || !m.current || d.activationTrigger === 0) return;\n    let O = be();\n    return O.requestAnimationFrame(() => {\n      var a, I;\n      (I = (a = f.current) == null ? void 0 : a.scrollIntoView) == null || I.call(a, {\n        block: \"nearest\"\n      });\n    }), O.dispose;\n  }, [f, u, d.comboboxState, d.activationTrigger, d.activeOptionIndex]);\n  let x = C(O => {\n      if (i) return O.preventDefault();\n      g(), d.mode === 0 && o.closeCombobox(), Be() || requestAnimationFrame(() => {\n        var a;\n        return (a = d.inputRef.current) == null ? void 0 : a.focus();\n      });\n    }),\n    L = C(() => {\n      if (i) return o.goToOption(y.Nothing);\n      o.goToOption(y.Specific, r);\n    }),\n    F = he(),\n    h = C(O => F.update(O)),\n    B = C(O => {\n      F.wasMoved(O) && (i || u || o.goToOption(y.Specific, r, 0));\n    }),\n    k = C(O => {\n      F.wasMoved(O) && (i || u && (d.optionsPropsRef.current.hold || o.goToOption(y.Nothing)));\n    }),\n    G = D(() => ({\n      active: u,\n      selected: P,\n      disabled: i\n    }), [u, P, i]);\n  return U({\n    ourProps: {\n      id: r,\n      ref: c,\n      role: \"option\",\n      tabIndex: i === !0 ? void 0 : -1,\n      \"aria-disabled\": i === !0 ? !0 : void 0,\n      \"aria-selected\": P,\n      disabled: void 0,\n      onClick: x,\n      onFocus: L,\n      onPointerEnter: h,\n      onMouseEnter: h,\n      onPointerMove: B,\n      onMouseMove: B,\n      onPointerLeave: k,\n      onMouseLeave: k\n    },\n    theirProps: n,\n    slot: G,\n    defaultTag: eo,\n    name: \"Combobox.Option\"\n  });\n}\nlet to = w(je),\n  no = w($e),\n  ro = w(Ke),\n  ao = w(Qe),\n  lo = w(ze),\n  io = w(oo),\n  Wo = Object.assign(to, {\n    Input: ro,\n    Button: no,\n    Label: ao,\n    Options: lo,\n    Option: io\n  });\nexport { Wo as Combobox };","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}